{"pages":[{"title":"About","date":"2017-10-02T02:24:00.000Z","path":"about/index.html","text":"关于我自己书山有路勤为径没有终点，过程即永恒"},{"title":"Categories","date":"2019-08-06T15:20:43.933Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-08-06T15:20:43.933Z","path":"tags/index.html","text":""}],"posts":[{"title":"spring-test","date":"2019-08-06T15:20:43.929Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring test/","text":"spring-boot-test示例【即@SpringBootConfiguration配合@SpringBootTest】 被测类class A。 配置类class B，需要用@SpringBootConfiguration。内部创建被测类class A的@bean。 测试类class C，需要用@SpringBootTest(classes=B.class)。至于RunWith不太讲究。 1234567891011121314151617181920212223242526public class Hello &#123; public String hello() &#123; return &quot;hello&quot;; &#125;&#125;@SpringBootConfigurationpublic class Config &#123; @Bean Hello makeHello() &#123; return new Hello(); &#125;&#125;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=Config.class)public class HelloTest &#123; @Autowired private Hello hello; @Test public void helloTest() &#123; String actual = hello.hello(); String expected = &quot;hello&quot;; assertEquals(expected, actual); &#125;&#125; 报错报错：NoClassDefFoundError: Could not initialize class org.springframework.test.context.junit4.SpringJUnit4ClassRunner12345678910111213&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.13.RELEASE&lt;/version&gt; &lt;relativePath /&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 报错：Unable to find suppressions file at location: src/checkstyle/checkstyle-suppressions.xml: Could not find resource ‘src/checkstyle/checkstyle-suppressions.xml’.12345678910111213&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;1.5.13.RELEASE&lt;/version&gt; &lt;relativePath /&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 正常 12345678910111213&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath /&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 正常12345678910111213&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath /&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring-boot-test","slug":"spring-boot-test","permalink":"http://yoursite.com/tags/spring-boot-test/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"gtest","date":"2019-07-31T13:15:58.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/gtest/","text":"official document github gtest primer gtest advanced gtest faq gmock cook_book for_dummies cheat_sheet 问题 C/C++ -&gt; Code Generation -&gt; Runtime Library Debug下， Multi-threaded Debug(/MTd) Release下，Multi-threaded(MT) VS2010使用GooglTest，GoogleMock","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"gtest","slug":"gtest","permalink":"http://yoursite.com/tags/gtest/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"python-加解密处理","date":"2019-07-15T22:16:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/python/library/encrypt/","text":"1 Python之MD5加密 Python中摘要算法MD5，SHA1讲解 用hashlib模块生成消息摘要 md5模块（Python内置模块）和hashlib模块 MD5 hash in Python","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"encrypt","slug":"encrypt","permalink":"http://yoursite.com/tags/encrypt/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"python","slug":"编程语言/python","permalink":"http://yoursite.com/categories/编程语言/python/"},{"name":"library","slug":"编程语言/python/library","permalink":"http://yoursite.com/categories/编程语言/python/library/"}]},{"title":"python-socket","date":"2019-07-14T22:25:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/python/library/socket/","text":"2 python socket Python Socket 编程详细介绍 python2 simplehttpserver python3 http.server python3 http.server usage","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"python","slug":"编程语言/python","permalink":"http://yoursite.com/categories/编程语言/python/"},{"name":"library","slug":"编程语言/python/library","permalink":"http://yoursite.com/categories/编程语言/python/library/"}]},{"title":"cpp-lzma","date":"2019-07-14T22:13:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/lzma/","text":"## How to compress a Folder uses lzma sdk Using 7-Zip from Delphi How to unzip an LZMA compressed zip file C++ LZMA SDK: Uncompress function for LZMA2 compressed file","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"lzma","slug":"lzma","permalink":"http://yoursite.com/tags/lzma/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"asm","date":"2019-06-08T22:51:00.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/hacker/windows/asm/","text":"asm __asm Blocks Using C or C++ in __asm Blocks 编译LDE64 My first Msgbox with ASM Tutorial 2: MessageBox Print Message Inline Assembly Hello world in C inline assembly Hello, world! “Hello, World” in x86 Assembly Language A guide to inline assembly for C and C++ ret, retn, retf - how to use them 汇编指令长度计算方法 汇编语言——汇编指令长度的判断 汇编指令长度的判断 LDE64 - x86 &amp; x64 instruction-length 汇编指令MOVSX与MOVZX How to Use Inline Assembly Language in C Code assembly tutorial vs assmebly error vs 内联汇编 “第一操作数”错误 vs inline assembly ibm inline assembly 1 retn—–return near————–pop eip retf———————pop eip; pop cs INTRINS.H学习header中定义的函数使用起来，会让你像在用汇编时一样简便。比如_crol_字符循环左移，_nop_空操作等 _ReturnAddress返回当前调用函数返回的地址，即函数下一跳指令地址 示例 __readgsqword从偏移量的指定位置读取内存相对 GS 段开头。有 byte、word、dword、qword 示例","tags":[{"name":"asm","slug":"asm","permalink":"http://yoursite.com/tags/asm/"}],"categories":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/categories/hacker/"},{"name":"windows","slug":"hacker/windows","permalink":"http://yoursite.com/categories/hacker/windows/"}]},{"title":"windows-hook","date":"2019-06-08T22:46:00.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/hacker/windows/windows-hook/","text":"windows api ResumeThread Memory Protection Constants VirtualProtect VirtualAlloc function Set-NetTCPSetting WriteProcessMemory WinAPI: Is it needed to call FlushInstructionCache on an executable memory-mapped file? FlushInstructionCache函数 FlushInstructionCache function 方式 Process Injection Techniques hunting-memory The different ways of hooking load symbols for a particular DLL Code Injection Technique Named PROPagate IAT/EAT hook with annotations Hooking Series PART I : Import Address Table Hooking Hooking the Export Address Table (EAT) - C++ EAT Hooking On DLL’s Export Address Table Hooking (EAT)? 导出表钩子——EAT HOOK 钩子编程 windows hook 导出表hook 导出表钩子 函数hook function hook hook specific function api hook and dll injection inline function hook inject Code Injection Image File Execution Options Injection Process Injection Code Injection Technique CODE INJECTION FOR WINDOWS 基于文件修改的注入方式 dll inject 代码注入–修改导入表IAT–通过系统回调函数","tags":[{"name":"pe","slug":"pe","permalink":"http://yoursite.com/tags/pe/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"},{"name":"hook","slug":"hook","permalink":"http://yoursite.com/tags/hook/"}],"categories":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/categories/hacker/"},{"name":"windows","slug":"hacker/windows","permalink":"http://yoursite.com/categories/hacker/windows/"}]},{"title":"windows-driver","date":"2019-06-08T22:46:00.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/hacker/windows/windows-driver/","text":"api driver(即内核编程)修改windows callback监控 windows driver programming MmIsAddressValid function (ntddk.h) IMAGE_INFO WDK headers WINCE driver using LoadLibrary PsGetCurrentProcessId WDK for Windows 10 ZwCreateSection Windows Wdk 编写第一个驱动程序.aspx) 编写通用 Hello World 驱动程序 (KMDF).aspx) Windows驱动开发如何入门 _WIN64 error “No Target Architecture” fatal error C1189: #error : “No Target Architecture”的解决方案 No target architecture defined - Ntddk.h Fatal error: “No Target Architecture” in Visual Studio","tags":[{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"},{"name":"driver","slug":"driver","permalink":"http://yoursite.com/tags/driver/"}],"categories":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/categories/hacker/"},{"name":"windows","slug":"hacker/windows","permalink":"http://yoursite.com/categories/hacker/windows/"}]},{"title":"tcp-basic","date":"2019-06-08T22:46:00.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/hacker/net/tcp/","text":"1 tcp_timestap socket EAGAIN tcp_windows_scaling iperf测试 windows auto tuning level Windows 7 TCP Stack tcp windows and window scaling","tags":[{"name":"IP","slug":"IP","permalink":"http://yoursite.com/tags/IP/"},{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"}],"categories":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/categories/hacker/"},{"name":"net","slug":"hacker/net","permalink":"http://yoursite.com/categories/hacker/net/"}]},{"title":"pe","date":"2019-06-05T23:00:00.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/hacker/windows/pe/","text":"定义 PE文件学习笔记（三）：导出表 pe重定位 pe section header pe format(msdn) pe导出表重组 pe 导出表 PE总结– EAT导出表 PE—IAT导入表 PE—.rdata modify .radata content Windows的TEB/PEB结构的检测调试原理 通过PEB获取模块基址 进程peb结构、获得peb的方法 PE文件知识在免杀中的应用 peb,teb研究 PEB, TEB PEB-Process-Environment-Block/BeingDebugged Peb(Process Environment Block)简单学习及分析 PE总结 – 导出表 Windows PE导出表编程4 4 PE Loader加载DLL的时候修改（这个DLL）自己的导出表 DllMain entry point enumerate dll export functions export dll function ntdll.dll vs pdb文件 int 3软中断 缓冲区溢出检查_security_cookie security cookie dll重定向 _usercall, __security_cookie 编译原理之可重定位代码","tags":[{"name":"pe","slug":"pe","permalink":"http://yoursite.com/tags/pe/"},{"name":"reverse engineer","slug":"reverse-engineer","permalink":"http://yoursite.com/tags/reverse-engineer/"}],"categories":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/categories/hacker/"},{"name":"windows","slug":"hacker/windows","permalink":"http://yoursite.com/categories/hacker/windows/"}]},{"title":"IDA","date":"2019-06-05T22:55:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/reverse engineer/windbg/","text":"1 windbg的导入函数、导出函数 windbg的用户态 windbg的dmp分析 Windbg入门 Windbg调试—-Windbg入门 windbg调试基础 windbg 命令手册 windbg和ollydbg对比 windows dmp文件分析","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"Windbg","slug":"Windbg","permalink":"http://yoursite.com/tags/Windbg/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"reverse engineer","slug":"工具/reverse-engineer","permalink":"http://yoursite.com/categories/工具/reverse-engineer/"}]},{"title":"IDA","date":"2019-05-13T22:30:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/reverse engineer/IDA/","text":"1 ida 操作 IDA-文本搜索、二进制搜索 ida 脚本查找指令 ida 脚本查找指令2 IDA Hex-Rays反编译器使用的一些小技巧 IDA静态分析与动态分析 IDA Pro 逆向速参 IDA简易教程 IDA 使用技巧 IDA Pro7.0使用技巧总结 IDA PRO新手使用教程 IDA Pro使用技巧及大杂烩","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"IDA","slug":"IDA","permalink":"http://yoursite.com/tags/IDA/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"reverse engineer","slug":"工具/reverse-engineer","permalink":"http://yoursite.com/categories/工具/reverse-engineer/"}]},{"title":"OllDbg","date":"2019-05-12T22:00:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/reverse engineer/OllyDbg/","text":"快捷键官网 Pop-up menus Function Window Menu command Shortcut Edit memory as binary, ASCII or UNICODE string Disassembler, Stack; Dump Binary/Edit Ctrl+E Undo changes Disassembler, Dump ;Registers Undo selection ;Undo Alt+BkSp Run application Main Debug/Run F9 Run to selection Disassembler `Breakpoint Run` to selection F4 Execute till return Main `Debug Execute till return` Ctrl+F9 Execute till user code Main `Debug Execute till user code` Alt+F9 Set/reset INT3 breakpoint Disassembler Names, Source `Breakpoint Toggle` Toggle breakpoint F2 Set/edit conditional INT3 breakpoint Disassembler Names, Source `Breakpoint Conditional` Conditional breakpoint Shift+F2 Set/edit conditional logging breakpoint (logs into the Log window) Disassembler Names, Source `Breakpoint Conditional` log Conditional log breakpoint Shift+F4 Temporarily disable/restore INT3 breakpoint Breakpoints Disable Enable Space Set memory breakpoint (only one is allowed) Disassembler, Dump `Breakpoint Memory, on accessBreakpoint Memory`, on write Remove memory breakpoint Disassembler, Dump Breakpoint Remove memory breakpoint Set hardware breakpoint (ME/NT/2000 only) Disassembler, Dump Breakpoint Hardware (select type and size!) Remove hardware breakpoint Main `Debug Hardware` breakpoints Set single-short break on access to memory block (NT/2000 only) Memory Set break-on-access F2 Set break on module, thread, debug string Options Events Set new origin Disassembler New origin here Display list of all symbolic names Disassembler, Dump Modules `Search for Name` (label) View names Ctrl+N Context-sensitive help (requires external help file!) Disassembler, Names Help on symbolic name Ctrl+F1 Find all references in code to selected address range Disassembler Dump `Find references to Command` Find references Ctrl+R Find all references in code to the constant Disassembler `Find references to ConstantSearch for All constants` Search whole allocated memory Memory Search Search next Ctrl+L Go to address or value of expression Disassembler Dump `Go to ExpressionGo to expression` Ctrl+G Go to previous address/run trace item Disassembler `Go to Previous` Minus Go to next address/run trace item Disassembler `Go to Next` Plus Go to previous procedure Disassembler `Go to Previous procedure` Ctrl+Minus Go to next procedure Disassembler `Go to Next procedure` Ctrl+Plus View executable file Disassembler, Dump, Modules `View Executable file` Copy changes to executable file Disassembler Copy to executable file Analyse executable code Disassembler Analysis Analyse code Ctrl+A Scan object files and libraries Disassembler Scan object files Ctrl+O View resources Modules, Memory View all resources View resource strings Suspend/resume thread Threads Suspend Resume Display relative addresses Disassembler, Dump, Stack Doubleclick address Copy Most of windows Copy to clipboard Ctrl+C global shortcuts 快捷键 功能 Ctrl+F2 Restart program Alt+F2 Close program F3 Open new program F5 Maximize/restore active window Alt+F5 Make OllyDbg topmost F7 Step into (entering functions) Ctrl+F7 Animate into (entering functions) F8 Step over (executing function calls at once) Ctrl+F8 Animate over (executing function calls at once) F9 Run Shift+F9 Pass exception to standard handler and run Ctrl+F9 Execute till return Alt+F9 Execute till user code Ctrl+F11 Trace into F12 Pause Ctrl+F12 Trace over Alt+B Open Breakpoints window Alt+C Open CPU window Alt+E Open Modules window Alt+L Open Log window Alt+M Open Memory window Alt+O Open Options dialog Ctrl+T Set condition to pause Run trace Alt+X Close OllyDbg Disasembler shortcuts 快捷键 功能 F2 Toggle breakpoint Shift+F2 Set conditional breakpoint F4 Run to selection Alt+F7 Go to previous reference Alt+F8 Go to next reference Ctrl+A Analyse code Ctrl+B Start binary search Ctrl+C Copy selection to clipboard Ctrl+E Edit selection in binary format Ctrl+F Search for a command Ctrl+G Follow expression Ctrl+J Show list of jumps to selected line Ctrl+K View call tree Ctrl+L Repeat last search Ctrl+N Open list of labels (names) Ctrl+O Scan object files Ctrl+R Find references to selected command Ctrl+S Search for a sequence of commands Asterisk (*) Origin Enter Follow jump or call Plus (+) Go to next location/next run trace item Minus (-) Go to previous location/previous run trace item Space ( ) Assemble Colon (:) Add label Semicolon (;) Add comment 命令栏以下命令使用于 OllyDbg 的快捷命令栏（显示于程序的状态栏上方）以下命令适用于 OllyDbg 的命令行插件 Cmdline.dll（显示于程序的插件菜单中） 命令 英文 功能 CALC 判断表达式 WATCH 添加监视表达式 AT / FOLLOW Disassemble at address 在地址进行反汇编 ORIG Disassemble at EIP 反汇编于 EIP DUMP Dump at address 在地址转存 DA Dump as disassembly 转存为反汇编代码 DB Dump in hex byte format 转存在十六进制字节格式 DC Dump in ASCII format 转存在 ASCII 格式 DD Dump in stack format 转存在堆栈格式 DU Dump in UNICODE format 转存在 UNICODE 格式 DW Dump in hex word format 转存在十六进制字词格式 STK Go to address in stack 前往堆栈中的地址 AS + 地址 + 字符串 Assemble at address 在地址进行汇编 L + 地址 + 字符串 Label at address 在地址进行标号 C + 地址 + 字符串 Comment at address 在地址进行注释 BP Break with condition 使用条件中断 BPX Break on all calls 中断在全部调用 BPD Delete break on all calls 清除位于全部调用的断点 BC Delete breakpoint 清除断点 MR Memory breakpt on access 内存断点于访问时 MW Memory breakpt on write 内存断点于写入时 MD Remove memory breakpoint 清除内存断点 HR HW break on access 硬件中断在访问 HW HW break on write 硬件中断在写入 HE HW break on execution 硬件中断在执行 HD Remove HW breakpoint 清除硬件断点 STOP Pause execution 暂停执行 PAUSE PAUSE RUN Run program 运行程序 Run till address 运行到地址 GE Run and pass exception 运行和通过例外 SI Step into 步入 SO Step over 步过 TI Trace in till address 跟踪进入直到地址 TO Trace over till address 跟踪步过直到地址 TC Trace in till condition 跟踪进入直到条件 TOC Trace over till condition 跟踪步过直到条件 TR Till return 直到返回 TU Till user code 直到用户代码 LOG View Log window 查看记录窗口 MOD View Modules window 查看模块窗口 MEM View Memory window 查看内存窗口 CPU View CPU window 查看 CPU 窗口 CS View Call Stack 查看 Call 堆栈 BRK View Breakpoints window 查看断点窗口 OPT Open Options 打开选项 EXIT / QUIT Quit OllyDbg 退出 OllyDbg OPEN Open executable file 打开可执行文件 CLOSE Close executable 关闭程序 RST Restart current program 恢复当前程序 HELP Help on API function API 函数的帮助 ASM Assemble (if command needs it’s own addres, \\”ASM COMMAND;ADDRESS\\”) 汇编 (如果命令需要自身的地址 \\”ASM COMMAND;ADDRESS\\”) DASM Disassemble immediate opcode 反汇编直接的机器码 FR Find reference to selected command/address 查找参考到选定的命令/地址 AC Analyse code 分析代码 SN Search for Name(label) in current module 在当前模块中搜索名称(标号) SOB Scan object files 扫描项目文件 1 Searching for strings in ollydbg ollydbg的字符串搜索 ollydbg ‘referenced string’ ollydbg插件合集 OllyDbg插件深入分析 OllyDbg快速查找指定代码四种方法 OllyDbg使用方法 always loads the code of ntdll and terminates the app Simple Program Being Paused Somewhere in ntdll Ollydbg “Single step event at ntdll“ OllyDbg/CommandLine OllyDbg使用入门 OllyDbg使用技巧总结 OllyDbg使用小技巧(慢慢积累) OllyDbg使用教程 OllyDbg 使用笔记 （一） Ollydbg使用技巧 OllyDbg Plugins OllyDBG完美教程(完美) How to automate task in OllyDBG ? module has entry point outside of code","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"OllDbg","slug":"OllDbg","permalink":"http://yoursite.com/tags/OllDbg/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"reverse engineer","slug":"工具/reverse-engineer","permalink":"http://yoursite.com/categories/工具/reverse-engineer/"}]},{"title":"linux","date":"2019-05-04T12:15:58.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/Operator System/linux/","text":"文档recursive mkdir： mkdir -p foo/bar/zoo/andsoforth ls ls -l (filename)显示用户、属性等信息 复制所有source文件夹下的内容cp -a /source/. /dst/ 更改文档属性可执行 find file by name/extension 用户、用户组 用who查看当前登录用户名 用groups XXX查看“XXX”所在的用户组 list all user Change File Ownership &amp; Groups ssh和scp“cloud” ————&gt; “local”上传 文件：scp username@servername:/path/filename local_dir 目录：scp -r username@servername:remote_dir local_dir “local”————&gt;“cloud” 下载 文件：scp /path/filename username@servername:/remote_dir 目录：scp -r local_dir username@servername:remote_dir 命令行浏览网页curl http://google.com可以制定代理、cookie、OPTION等，自己玩吧。 后台运行nohup ping google.com &amp; 标准输出和错误会定向到nohup.out中。 nohup顾名思义，提交的命令忽略”hang up“信号。 重定向报错curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh &gt; /usr/local/bin/docker-compose 可以用sudo bash -c &quot;echo N&gt; /sys/module/drm_kms_helper/parameters/poll&quot;让他在sudo bash -c &quot;&quot;中运行。 端口查看端口使用参考 netstat -l或者netstat --listen 查看历史纪录12345678cat ~/.bash_historyless ~/.bash_history#The history size defaults to 500 commands. You can, however, increase this by adding the following line to your ~./bashrc:HISTSIZE=&lt;number of entries, -1 for unlimited&gt;history 环境变量查看echo $PATHprintf &quot;%s\\n&quot; $PATHecho $PATH | tr &quot;:&quot; &quot;\\n&quot; | nl新增或修改export PATH=$PATH:/opt/gamesexport CATALINA_HOME=/path/to/the/root/folder/of/tomcat取消或删除unset PATH process kill ctrl+z比如在vim下，使用ctrl+z会将vim切换至后台，然后就可以看到前台的terminal。有点像是视窗os的tab的功能 可以在terminal中使用fg就能看到，然后再切换过去 延申类似功能The general job control commands in Linux are: jobs - list the current jobs fg - resume the job that’s next in the queue fg %[number] - resume job [number] bg - Push the next job in the queue into the background bg %[number] - Push the job [number] into the background kill %[number] - Kill the job numbered [number] kill -[signal] %[number] - Send the signal [signal] to job number [number] disown %[number] - disown the process(no more terminal will be owner), so command will be alive even after closing the terminal. service run","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"Operator System","slug":"工具/Operator-System","permalink":"http://yoursite.com/categories/工具/Operator-System/"}]},{"title":"pycrypto","date":"2019-04-27T14:57:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/开源库/python/pycrypto/","text":"报错 pycrypto: No module named strxor解决办法 官网解决方案 12pip install pycryptopip install pycryptodome 使用 pkcs定义 PBKDF2 RFC8018定义了PKCS JDK default Crypto/AES behavior Load RSA Private Key From File 信息安全python库PyCrypto RSA 报错 plain text too long RSA加解密 RSA长字符串加密 Asymmetric cryptography - Plaintext size error Base64 encoding rfc 3548","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"},{"name":"crypt","slug":"crypt","permalink":"http://yoursite.com/tags/crypt/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"python","slug":"开源库/python","permalink":"http://yoursite.com/categories/开源库/python/"}]},{"title":"pandas","date":"2019-04-27T14:57:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/开源库/python/pandas/","text":"Series类似于”一维数组”的对象,由”一组数据(各种NumPy数据类型)”,以及,”一组与之相关的数据标签即Index”,组成.","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"},{"name":"pandas","slug":"pandas","permalink":"http://yoursite.com/tags/pandas/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"python","slug":"开源库/python","permalink":"http://yoursite.com/categories/开源库/python/"}]},{"title":"numpy","date":"2019-04-27T14:57:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/开源库/python/numpy/","text":"针对matrix主要是为了和matlab接轨，使用起来和代码编写比较统一 使用variable创建matrixM= np.matrix([[x,y],[w,z]]) 每一个commas都不能省略！！！不能用whitespace来分列，也不能用semicolons来分行 使用zeros创建matrix而不是narrayM= np.matlib.zeros((4,5)) 虚数Imaginary问题To avoid the invalid value warning/error, the argument to numpy’s sqrt function must be complex: 12import numpy as npnp.sqrt(-1+0j) 即你得传递的变量或者生成的临时变量是Imaginary type，这样sqrt生成的值才会是Imaginary type，他和C/C++一样，不会跳着变Data Type的！！！以后 numpy 一旦出现数值计算错误，一定要记得考虑这个问题，我们不可能像matlab那么牛b，总是会自动跳成虚数形式的！！！ python这种脚本型解释性语言，看似无类型，但是你用类型的内部定义函数时，就有了 无穷infinity无限(有正负之分，positive or negative) ;或者Not a Number（简称NAN) 创建线性向量第一个np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)第二个np.arange([start,] stop[, step,][, dtype]) Values are generated within the half-open interval [start, stop) (in other words, the interval including start but excluding stop). numpy数据类型不知道是不是我使用的问题，类型统一，好像没有MATLAB那么随意，例子就是， 我的一个func返回了三个值，这三个值，我以为是简简单单的float型，可实际是array即[[]]，然后我用这个数据，去创建matrix，结果肯定不行啊，numpy是不允许嵌套matrix！！！ 重点在于使用sio.savemat它的定义是save a dictionary of names and arrays into MAT file.所以你拿出来的时候也必须得脱掉这层外，如果必要的话。 画图的时候不让使用matrix格式，必须得用array格式。所以必须用到函数np.matrix().getA()就可以获得一个array了。不然一直报一个很奇怪的错误： ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all() array数据类型index示例 123a[1][1]a[1, 1]b[1, -1] 都是可以的 filter, matlab与scipy区别This is not a bug. Matlab‘s filter operates on the first dimension of the array, while scipy.signal.lfilter by default operates on the the last dimension. From your question I see that your data array has a second dimension (perhaps empty?). When you use lfilter it defaults to axis=-1, which will give the answer you got for python. If you want the same behaviour of matlab you need to specify the first axis or squeeze the array (if the second dimension has a size of 1): 12out = lfilter(b, a, data, axis=0)out = lfilter(b, a, np.squeeze(data))","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"},{"name":"numpy","slug":"numpy","permalink":"http://yoursite.com/tags/numpy/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"python","slug":"开源库/python","permalink":"http://yoursite.com/categories/开源库/python/"}]},{"title":"scipy","date":"2019-04-27T14:57:49.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/python/SciPy/","text":"Matrix Objects出自1.6.2即隶属Arrary Objects-&gt;Standard Array Subclasses-&gt; matrix objects inherit from the ndarray and therefore, they have the same attributes and methods of ndarrays.There are six important differences of matrix objects, however, that may lead to unexpected results when you use matrices but expect them to act like arrays: Matrix objects can be created using a string notation to allow Matlab-style syntax where spaces separate columns and semicolons (‘;’) separate rows. Matrix objects are always two-dimensional. This has far-reaching implications, in that m.ravel() is still two dimensional (with a 1 in the first dimension) and item selection returns two-dimensional objects so that sequence behavior is fundamentally different than arrays. Matrix objects over-ride multiplication to be matrix-multiplication. Make sure you understand this for functions that you may want to receive matrices. Especially in light of the fact that asanyarray(m) returns a matrix when m is a matrix. Matrix objects over-ride power to be matrix raised to a power. The same warning about using power inside a function that uses asanyarray(...) to get an array object holds for this fact. The default __array_priority__ of matrix objects is 10.0, and therefore mixed operations with ndarrays always produce matrices. Matrices have special attributes which make calculations easier. These are Title1 Title2 matrix.T Returns the transpose of the matrix. matrix.H Returns the (complex) conjugate transpose of self. matrix.I Returns the (multiplicative) inverse of invertible self. matrix.A Return self as an ndarray object. Matrix library (numpy.matlib)This module contains all functions in the numpy namespace, with the following replacement functions that return matrices instead of ndarrays. 这个不好用，别被坑了 sci.optimize.fsolve解方程，屌屌的，仔细体会下面代码 利用2个关系式，解2元方程组 法一(lambda表达式) 12func = lambda x:(x[0]**2+x[1]**2-R**2, (x[0]**2+x[1]**2)/R**2-np.cos(beta))x, y = sci.optimize.fsolve(func,[0,1]) 法二(def形式) 123456def equations(p): y,z = p f1 = -10*z + 4*y*z - 5*y + 4*z**2 - 7 f2 = 2*y*z + 5*y - 3 return (f1,f2) y,z = sci.optimize.fsolve(equations,[0,1]) 利用1个关系式、一个元的某个解，求解另一个元的解 1234&gt;&gt;&gt; x0=[3,4,5]&gt;&gt;&gt; f = lambda x: [x[0]*14.80461-x[1]*4.9233+x[2]*10*0.4803, 0 , 0]&gt;&gt;&gt; fsolve(f,x0)array([-0.29192258, 4. , 5. ]) 此处python就会假定x[1]=4, x[2]=5求解得x[0]=-0.2919 注意如果要多个根root，请注意下面的例子： 12345678910111213141516171819202122232425f = lambda x: x**2-1&gt;&gt;&gt; fsolve(f, np.array([-10, 0.5]))array([-1., -1.])&gt;&gt;&gt; fsolve(f,np.array([-10,1.1]))array([-1., 1.])&gt;&gt;&gt; fsolve(f, np.array([-10, 0]))array([-10., 0.])&gt;&gt;&gt; fsolve(f,np.array([-10, -2]))array([-1., -1.])&gt;&gt;&gt; fsolve(f,np.array([1.1,-2]))array([ 1., -1.])&gt;&gt;&gt; fsolve(f,np.array([1.1,0.1]))array([ 1., 1.])&gt;&gt;&gt; fsolve(f,np.array([1.1, -0.5]))array([ 1., -1.])&gt;&gt;&gt; fsolve(f,[1.1, -2])array([ 1., -1.]) 总结就是： 不要将猜测值设为0，系统不认识 也不要设置成0.x，系统认识，但是他会重复之前的结果 要得到多个解，请用array格式，不管是np.array([ , ,])还是[ , ,] File IO (scipy.io)数据流的保存方式 MATLAB filesLoad MATLAB file :Parameters: file_name : str Name of the mat file (do not need .m loadmat(file_name[, mdict, appendmat]) Save a dictionary of names and arrays into a MATLAB-style .mat file.注意： 确实是只能一个变量，然后在后面还不能append，感觉好蠢。额，是我蠢了，可以好几个，你保存得是python的dist，肯定可以好几个啊，被举例给误导了。 默认是保存为.mat格式，所以filename可以不加.mat scipy.io.savemat(file_name, mdict, appendmat=True, format=’5’, long_field_names=False, do_compression=False, oned_as=’row’) savemat(file_name, mdict[, appendmat, …])List variables inside a MATLAB file :Parameters: file_name : str Name of the mat file whosmat(file_name[, appendmat]) The basic functions We’ll start by importing scipy.io and calling it sio for convenience: &gt;&gt;&gt; import scipy.io as sio If you are using IPython, try tab completing on sio. Among the many options, you will find: sio.loadmat sio.savemat sio.whosmat These are the high-level functions you will most likely use when working with MATLAB files. You’ll also find: sio.matlab This is the package from which loadmat, savemat and whosmat are imported. Within sio.matlab, you will find the mio module This module contains the machinery that loadmat and savemat use. From time to time youmay find yourself re-using this machinery. How do I start?You may have a .mat file that you want to read into Scipy. Or, you want to pass some variables from Scipy / Numpy into MATLAB. To save us using a MATLAB license, let’s start in Octave. Octave has MATLAB-compatible save and load functions.Start Octave (octave at the command line for me): octave:1&gt; a = 1:12 a = 1 2 3 4 5 6 7 8 9 10 11 12 octave:2&gt; a = reshape(a, [1 3 4]) a = ans(:,:,1) = 1 2 3 ans(:,:,2) = 4 5 6 ans(:,:,3) = 7 8 9 ans(:,:,4) = 10 11 12 octave:3&gt; save -6 octave_a.mat a % MATLAB 6 compatible octave:4&gt; ls octave_a.mat octave_a.mat Now, to Python: &gt;&gt;&gt; mat_contents = sio.loadmat(&apos;octave_a.mat&apos;) &gt;&gt;&gt; mat_contents {’a’: array([[[ 1., 4., 7., 10.], [ 2., 5., 8., 11.], [ 3., 6., 9., 12.]]]), ’__version__’: ’1.0’, ’__header__’: ’MATLAB 5.0 MAT-file, written by Octave 3.6.3, 2013-02-17 21:02:11 UTC’, ’__globals__’: []} &gt;&gt;&gt; oct_a = mat_contents[’a’] &gt;&gt;&gt; oct_a array([[[ 1., 4., 7., 10.], [ 2., 5., 8., 11.], [ 3., 6., 9., 12.]]]) &gt;&gt;&gt; oct_a.shape (1, 3, 4) Now let’s try the other way round: &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; vect = np.arange(10) &gt;&gt;&gt; vect.shape (10,) &gt;&gt;&gt; sio.savemat(’np_vector.mat’, {’vect’:vect}) Then back to Octave: octave:8&gt; load np_vector.mat octave:9&gt; vect vect = 0 1 2 3 4 5 6 7 8 9 octave:10&gt; size(vect) ans = 1 10 If you want to inspect the contents of a MATLAB file without reading the data into memory, use the whosmat command: &gt;&gt;&gt; sio.whosmat(’octave_a.mat’) [(’a’, (1, 3, 4), ’double’)] whosmat returns a list of tuples, one for each array (or other object) in the file. Each tuple contains the name, shape and data type of the array. MATLAB structsMATLAB structs are a little bit like Python dicts, except the field names must be strings. Any MATLAB object can be a value of a field. As for all objects in MATLAB, structs are in fact arrays of structs, where a single struct is an array of shape (1, 1). octave:11&gt; my_struct = struct(’field1’, 1, ’field2’, 2) my_struct = { field1 = 1 field2 = 2 } octave:12&gt; save -6 octave_struct.mat my_struct We can load this in Python: &gt;&gt;&gt; mat_contents = sio.loadmat(’octave_struct.mat’) &gt;&gt;&gt; mat_contents {’my_struct’: array([[([[1.0]], [[2.0]])]], dtype=[(’field1’, ’O’), (’field2’, ’O’)]), ’__version__’: ’1.0’, ’__header__’: ’MATLAB 5.0 MAT- &gt;&gt;&gt; oct_struct = mat_contents[’my_struct’] &gt;&gt;&gt; oct_struct.shape (1, 1) &gt;&gt;&gt; val = oct_struct[0,0] &gt;&gt;&gt; val ([[1.0]], [[2.0]]) &gt;&gt;&gt; val[’field1’] array([[ 1.]]) &gt;&gt;&gt; val[’field2’] array([[ 2.]]) &gt;&gt;&gt; val.dtype dtype([(’field1’, ’O’), (’field2’, ’O’)]) In versions of Scipy from 0.12.0, MATLAB structs come back as numpy structured arrays, with fields named for the struct fields. You can see the field names in the dtype output above. Note also: &gt;&gt;&gt; val = oct_struct[0,0] and: octave:13&gt; size(my_struct) ans = 1 1 So, in MATLAB, the struct array must be at least 2D, and we replicate that when we read into Scipy. If you want all length 1 dimensions squeezed out, try this: &gt;&gt;&gt; mat_contents = sio.loadmat(’octave_struct.mat’, squeeze_me=True) &gt;&gt;&gt; oct_struct = mat_contents[’my_struct’] &gt;&gt;&gt; oct_struct.shape () Sometimes, it’s more convenient to load the MATLAB structs as python objects rather than numpy structured arrays - it can make the access syntax in python a bit more similar to that in MATLAB. In order to do this, use the struct_as_record=False parameter setting to loadmat. &gt;&gt;&gt; mat_contents = sio.loadmat(’octave_struct.mat’, struct_as_record=False) &gt;&gt;&gt; oct_struct = mat_contents[’my_struct’] &gt;&gt;&gt; oct_struct[0,0].field1 array([[ 1.]]) struct_as_record=False works nicely with squeeze_me: &gt;&gt;&gt; mat_contents = sio.loadmat(’octave_struct.mat’, struct_as_record=False, squeeze_me=True) &gt;&gt;&gt; oct_struct = mat_contents[’my_struct’] &gt;&gt;&gt; oct_struct.shape # but no - it’s a scalar Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; AttributeError: ’mat_struct’ object has no attribute ’shape’ &gt;&gt;&gt; type(oct_struct) &lt;class ’scipy.io.matlab.mio5_params.mat_struct’&gt; &gt;&gt;&gt; oct_struct.field1 1.0 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; AttributeError: ’mat_struct’ object has no attribute ’shape’ Saving struct arrays can be done in various ways. One simple method is to use dicts: &gt;&gt;&gt; a_dict = {’field1’: 0.5, ’field2’: ’a string’} &gt;&gt;&gt; sio.savemat(’saved_struct.mat’, {’a_dict’: a_dict}) loaded as: octave:21&gt; load saved_struct octave:22&gt; a_dict a_dict = scalar structure containing the fields: field2 = a string field1 = 0.50000 You can also save structs back again to MATLAB (or Octave in our case) like this: &gt;&gt;&gt; dt = [(’f1’, ’f8’), (’f2’, ’S10’)] &gt;&gt;&gt; arr = np.zeros((2,), dtype=dt) &gt;&gt;&gt; arr array([(0.0, ’’), (0.0, ’’)], dtype=[(’f1’, ’&lt;f8’), (’f2’, ’S10’)]) &gt;&gt;&gt; arr[0][’f1’] = 0.5 &gt;&gt;&gt; arr[0][’f2’] = ’python’ &gt;&gt;&gt; arr[1][’f1’] = 99 &gt;&gt;&gt; arr[1][’f2’] = ’not perl’ &gt;&gt;&gt; sio.savemat(’np_struct_arr.mat’, {’arr’: arr}) MATLAB cell arraysCell arrays in MATLAB are rather like python lists, in the sense that the elements in the arrays can contain any type of MATLAB object. In fact they are most similar to numpy object arrays, and that is how we load them into numpy. octave:14&gt; my_cells = {1, [2, 3]} my_cells = { [1,1] = 1 [1,2] = 2 3 } octave:15&gt; save -6 octave_cells.mat my_cells Back to Python: &gt;&gt;&gt; mat_contents = sio.loadmat(’octave_cells.mat’) &gt;&gt;&gt; oct_cells = mat_contents[’my_cells’] &gt;&gt;&gt; print(oct_cells.dtype) object &gt;&gt;&gt; val = oct_cells[0,0] &gt;&gt;&gt; val array([[ 1.]]) &gt;&gt;&gt; print(val.dtype) float64 Saving to a MATLAB cell array just involves making a numpy object array: &gt;&gt;&gt; obj_arr = np.zeros((2,), dtype=np.object) &gt;&gt;&gt; obj_arr[0] = 1 &gt;&gt;&gt; obj_arr[1] = ’a string’ &gt;&gt;&gt; obj_arr array([1, ’a string’], dtype=object) &gt;&gt;&gt; sio.savemat(’np_cells.mat’, {’obj_arr’:obj_arr}) octave:16&gt; load np_cells.mat octave:17&gt; obj_arr obj_arr = { [1,1] = 1 [2,1] = a string } IDL filesRead an IDL .sav file :Parameters: file_name : str Name of the IDL save file. readsav(file_name[, idict, python_dict, ...]) Matrix Market filesQueries the contents of the Matrix Market file ‘filename’ to extract size and storage mminfo(source) Reads the contents of a Matrix Market file ‘filename’ into a matrix. mmread(source) Writes the sparse or dense array a to a Matrix Market formatted file. mmwrite(target, a[, comment, field, precision]) Wav sound files (scipy.io.wavfile)Return the sample rate (in samples/sec) and data from a WAV file :Parameters: filename : string or ope read(filename[, mmap]) Write a numpy array as a WAV file :Parameters: filename : string or open file handle Output wav file ra write(filename, rate, data) Arff files (scipy.io.arff)Module to read ARFF files, which are the standard data format for WEKA.ARFF is a text file format which support numerical, string and data values. The format can also represent missing data and sparse data.See the WEKA website for more details about arff format and available datasets. Examples&gt;&gt;&gt; from scipy.io import arff &gt;&gt;&gt; from cStringIO import StringIO &gt;&gt;&gt; content = &quot;&quot;&quot; ... @relation foo ... @attribute width numeric ... @attribute height numeric ... @attribute color {red,green,blue,yellow,black} ... @data ... 5.0,3.25,blue ... 4.5,3.75,green ... 3.0,4.00,red ... &quot;&quot;&quot; &gt;&gt;&gt; f = StringIO(content) &gt;&gt;&gt; data, meta = arff.loadarff(f) &gt;&gt;&gt; data array([(5.0, 3.25, ’blue’), (4.5, 3.75, ’green’), (3.0, 4.0, ’red’)], dtype=[(’width’, ’&lt;f8’), (’height’, ’&lt;f8’), (’color’, ’|S6’)]) &gt;&gt;&gt; meta Dataset: foo width’s type is numeric height’s type is numeric color’s type is nominal, range is (’red’, ’green’, ’blue’, ’yellow’, ’black’) Read an arff file. loadarff(f) Netcdf (scipy.io.netcdf)A file object for NetCDF data. netcdf_file(filename[, mode, mmap, version]) Allows reading of NetCDF files (version of pupynere package)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"},{"name":"scipy","slug":"scipy","permalink":"http://yoursite.com/tags/scipy/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"python","slug":"开源库/python","permalink":"http://yoursite.com/categories/开源库/python/"}]},{"title":"pywin32","date":"2019-04-23T14:57:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/开源库/python/win32/","text":"pywin32pypiwin32 包含win32com github wmi参考msdn list-all-running-processes wmi教程 wmi库 wmi库示例 WinMgmts: win32com Win32_PerfFormattedData pdh 参考msdn win32pdh 示例 ctyps配合windll.psapi和windll.kernel32 示例","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"pywin32","slug":"pywin32","permalink":"http://yoursite.com/tags/pywin32/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"python","slug":"开源库/python","permalink":"http://yoursite.com/categories/开源库/python/"}]},{"title":"pugiXML","date":"2019-04-23T14:15:58.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/pugiXML/","text":"示例 生成全新的 github 官网 1 转成string","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"pugiXML","slug":"pugiXML","permalink":"http://yoursite.com/tags/pugiXML/"},{"name":"xml","slug":"xml","permalink":"http://yoursite.com/tags/xml/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"VMware","date":"2019-04-22T15:52:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/vmware/","text":"网络配置 3种配置 vm两个host-only虚拟机无法ping，关闭防火墙","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"OS","slug":"OS","permalink":"http://yoursite.com/tags/OS/"},{"name":"virtual machine","slug":"virtual-machine","permalink":"http://yoursite.com/tags/virtual-machine/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"scapy","date":"2019-04-13T07:24:00.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/开源库/python/scapy/","text":"issuescapy 2.4.2 &amp; Windows 10 =&gt; ImportError: cannot import name ‘NPCAP_PATH’ find ip local ip local-ip Hostname and IP python.scapy scapy and an IP Scapy","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"scapy","slug":"scapy","permalink":"http://yoursite.com/tags/scapy/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"python","slug":"开源库/python","permalink":"http://yoursite.com/categories/开源库/python/"}]},{"title":"Kali Linux Tools","date":"2019-04-13T06:14:54.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/hacker/kali-linux/","text":"Kali Linux Tools ListingTools Listing Gui Cmd-line Shell[可交互] Information Gathering 信息收集 name mode function comment DMitry ? whois查询/子域名收集/端口扫描 whois并不简单明了；子域名和邮箱依赖google；端口扫描速度一般 dnmap ? 用于组建分布式nmap，dnmap_server为服务端；dnmap_client为客户端 用起来并不是那么方便，不是实在不行不是很必要 ike-scan ?官网没了 收集ipsec vpn server指纹信息 好像用于攻击vpn，不太懂 maltegoce G官网没了 域名/账号等关联性收集展示(通过网络搜索，获取某个IP或邮箱与其他IP或邮箱的拓扑关系) 关联性展示功能确实很好，但效果可能没有那么理想，特别是对国内而言(这东西有那么强，但社工的东西还是没那么强，而且还是外国的工具在天朝的网络) netdiscover ?官网没了 主动发出arp包和截获arp包 就arp探测功能就此功能本身而言做得算很好了 Nmap C 端口服务探测和端口漏洞扫描 端口扫描集大成者 p0f C 监听网卡收发的数据包，从数据包中读取远端机器操作系统服务版本等信息 毕竟只是截取数据 包中的版本信息，效果期望不要很大 regon-ng S官网没了 模仿msf的信息侦查框架 类似将站长工具等东西命令行化，想法挺好但是用起来感觉不是那么直观 SPARTA G 图形版的hydra，加了端口服务扫描功能 还行图形界面聊胜于无 zenmap G官网没了 图形界面版的nmap 还行图形界面聊胜于无 GoLismero C 就是一个文本版的类似awvs的web扫描器 感觉可以提升对扫描器原理的认识 Faraday G 报告管理 ace-voipAmapAPT2arp-scanAutomaterbing-ip2hostsbraaCaseFileCDPSnarfcisco-torchcopy-router-config dnsenumdnsmapDNSRecondnstracerdnswalkDotDotPwnenum4linuxenumIAXEyeWitness FierceFirewalkfragroutefragrouterGhost Phisher goofilehping3ident-user-enumInSpyInTraceiSMTPlbdMaltego TeethmasscanMetagoofilMirandanbtscan-unixwizNiktontopOSRFramework ParseroRecon-ngSETSMBMapsmtp-user-enumsnmp-check sslcauditSSLsplitsslstripSSLyzeSublist3rTHC-IPV6theHarvesterTLSSLedtwofiUnicornscanURLCrazyWiresharkWOL-EXplico Vulnerability Analysis系统审计/扫描/分析 name mode function comment Lynis ? 感觉有点像360首页的“立即体验”，不过只是扫描告警不能一键修复 shell脚本写成颇为有趣 unix-privesc-check ? 审计系统中的关键文件权限是否有异常 还是没有总结性展示和修复功能 bed 通过发送各种模糊数据测试多种服务的缓冲区溢出漏洞的工具 可能还不错 commix sqlmap检测sql注入此工具检测系统命令注入 两相搭配那注入基本覆盖了 Oscanner C 用字典探查oracle数据库是否监听及猜解服务名 参数很少。测试sid和默认用户是可以的，默认的字典基本没法看还是得自己写字典 SidGuesser C 用字典探测oracle数据库存在的sid 参数很少。测试验证如果字典里有sid，可以探测出sid。基于字典的工具还是得自己准备字典 tnscmd10g C 用于探测oracle是否监听及其他一些信息 BBQSQLBEDcisco-auditing-toolcisco-global-exploitercisco-ocscisco-torchcopy-router-configDoonaDotDotPwnHexorBasejSQL Injection Nmapohrwurmopenvas Powerfuzzersfuzz SIPArmyKnifesqlmapSqlninjasqlsusTHC-IPV6 Yersinia Exploitation Tools name mode function comment Armitage G measploit的gui界面 嗯好像是比原来的msf-gui好点，不过叫人自己去启动msf还要登录，还是不用算了 BeEF C 利用msf的exp结合xss构造有攻击性的html页面，当浏览器访问即会受到攻击并获取shell 这可以啊，不过不懂对现在浏览器效果怎么样 Metasploit Framework S 就是启动msf console咯.一款开源的安全漏洞检测工具供开发，测试和使用恶意代码，收集了数百个实用的溢出攻击程序及一些辅助工具，让人们使用简单的方法完成安全漏洞检测，即使一个不懂安全的人也可以轻松的使用它。 msf payload center C官网无 生成包含exp的windows/android等各平台的可执行文件，木马制作利器 那这东西和msf venom的区别是什么 search sploit C 用于搜索已从exploitdb下载到本地的漏洞利用脚本 可以理解msf都是ruby写的可执行代码，exploit不一定用ruby写，也可能只是扫描述而非代码 Backdoor Factory Maltego Teeth 图形化界面，是一款社会工程学分析软件，很强大。只需要一个网站或一个姓名一个email就能以蜘蛛网的形式给出千丝万缕的联系。收集某个人的在线数据信息 – 包括电子邮件地址、博客、Facebook中的朋友，个人爱好、地理位置、工作描述等信息。 cisco-auditing-toolcisco-global-exploitercisco-ocscisco-torchCommixcrackleexploitdbjboss-autopwnLinux Exploit Suggester MSFPCRouterSploitSETShellNoobsqlmapTHC-IPV6Yersinia Wireless Attacks name mode function comment Pyrit C WPA/WPA2加密的wifi的密码破解工具 Aircrack-ng C 针对WEP、 WPA加密方式的wifi密码破解套件 chrip G官网无 各种无线电数据包的拦截工具（？） coWPAtty C 基于已捕获握手包和密码字典的WPA-PSK加密的wifi密码的猜解 不能自己拦截数据包也只能破解WPA-PSK类加密方式功能有点弱 Fern Wifi Cracker G 基于字典的WEP和WPA加密的wifi破解工具 能自动发现wifi能拦截数据包，图形界面操作，简单易用 Ghost Phisher G 能发现AP并使与AP连接的设备断开连接然后假冒AP让设备重新连接 图形界面除了AP外还有假冒DNS、http服务器等，较为好用 GISKismet G Kismet输出结果的可视化工具，即较成text、html等各种格式 Kismet S 交互式的AP发现工具，列出周围AP的各种信息 mdk3 C 可向AP发送大量连接、断开请求，可向周围设备告知存在根本不存在的大量AP 这工具的攻击方法简直是发了疯 mfor C官网无 IC卡密钥破解程序 各种免费吃饭充钱教程里用的工具你想不想学 mfterm S 交互式IC卡文件写入工具 要修改卡内数据才是最终的IC卡破解 PixieWPS C 针对开启WPS的wifi利用WPS随机数生成中的bug来破解 有说很快有说成功率比较低 Reaver C 针对开启WPS的wifi进行暴力破解的工具 aircrack-ng后排名第二的wifi破解工具 Wifite C 较为自动化的wifi破解工具 Airbase-ng Airdecap-ng and Airdecloak-ngAireplay-ngairgraph-ngAirmon-ngAirodump-ngairodump-ng-oui-updateAirolib-ngAirserv-ngAirtun-ngAsleapBesside-ngBluelogBlueMahoBluepotBlueRangerBluesnarferBully crackleeapmd5passEasside-ng FreeRADIUS-WPE Gqrxgr-scanhostapd-wpeivstoolskalibrate-rtlKillerBee makeivs-ng mfcukmfoc Multimon-NGPacketforge-ng redfangRTLSDR ScannerSpooftoophTkiptun-ngWesside-ngWifi HoneywifiphisherWifitap wpaclean Forensics Tools name mode function comment Binwalk C 用于分析一个文件中是否其实有多个文件 ctf的key文件提取就常用到的 bulk-extractor C 扫描给定的目录或文件，如果发现一些如电话号码网址等关键的信息则输出到文件 chkrootkit C官网无 扫描本机，查看本机是否存在受rootkit影响的地方 理解成360的木马查杀也差不多 Foremost C 文件恢复工具，用于被删除的文件的恢复，就是360等的那个文件恢复功能 Galleta C 用于分析IE的cookie文件输出其中的有用信息 Volatility C [ volafox的扩展，支持Mac OS X/Linux/Windows] 针对Mac OS X的内存分析工具，可从其内存镜像中读取进程列表等各种主机信息 先用工具把当前内存抓取下来，然后再用来分析；内存数据容易被破坏所以这确实很有意义 CapstonechntpwCuckoodc3ddddrescueDFFdiStorm3Dumpzillaextundelete GuymageriPhone Backup Analyzerp0fpdf-parserpdfidpdgmailpeepdfRegRipper Xplico Web Applications name mode function comment Nikto ？ web扫描器 就喜欢这种直接告漏洞的扫描器（不过事实上很少能有可用的漏洞） Burp Suite 常用web代理截包工具 功能强大不能要求更多 httrack 将网站克隆到本地 钓鱼乌云等可能有用 owasp-zap G owasp组织开发的工具 和burpsuite相比弱化了截包功能，强化了web漏洞扫描功能，不过感觉也没扫出什么东西 Paros G 一个web爬行和漏扫工具 和owasp-zap差不多 Skipfish C 一个全自动化的web漏洞扫描工具 其工作一是爬行网站页面，然后分析页面漏洞，最后生html报告 sqlmap C 一个强大的sql注入扫描工具 w3af G/S 一个web漏洞扫描框架 所谓框架就是有一堆扫描模块，然后你选定其中一些模块去扫描网站；感觉一般没说的那么好 WebScarab G 更专业的网站树型结构分析工具 WPScan 针对wordpress的漏洞扫描工具 BBQSQL S 一个高度可配置的交互式的sql盲注工具 jSQL Injection G 根据url探测数据库类型/参数注入测试/探测后台页而/探测重要文件 mdb-sql C官网无 可用来连接access数据库文件（mdb）然后通过sql语句查询数据 sqllite database G官网没了 qlite数据库客户端 Sqlninja C 用于猜解ms sql sqlsus C 用于mysql的盲注检测 autopsy web官网无 启动一个服务通过浏览器访问使用，感觉是分析网页各种元素的不是很懂 zaproxy web安全扫描工具，其中OWASP已经成了web安全的规范，好多工作求职时需要熟悉top10的缺陷及其修复。个人测试偶尔有误报 apache-usersArachni BlindElephant CutyCaptDAVTestdeblazeDIRBDirBusterfimapFunkLoadGobusterGrabberhURLjboss-autopwnjoomscan Maltego Teeth PadBuster ParseroplecostPowerfuzzerProxyStrikeRecon-ng ua-testerUniscan WebshagWebSlayerWebSploitWfuzzWhatWeb XSSer Stress Testing name mode function comment Termineter S 智能电表攻击框架 这需要硬件搭配吧，没玩过 DHCPigFunkLoadiaxfloodInundatorinvitefloodipv6-toolkitmdk3ReaverrtpfloodSlowHTTPTestt50 THC-IPV6THC-SSL-DOS Sniffing &amp; Spoofing name mode function comment driftnet C官网无 用于嗅探流量中的图版并展示到x-window上 配上arp欺骗作为中间人才能发挥威力，自己拦自己的就好玩而已 bettercap G 听说可以截持同子网的流量，强无敌，原理是什么 hampster C官网无 好像也是代理转发流量的 bdf proxy ?官网无 处于中间人身份时可对经过的流量插入payload mac changer C官网无 修改本机上网时的mac地址，一用作身份隐藏，二可用来绕过wifi mac黑名单 应该只是软修改mac地址不可能可写吧 mitm proxy C 好像也是代理转发流量的 感觉没什么特色啊 netsniff-ng C官网无 高性能的流量捕获套件，可能大流量时的捕获效果比较稳定 responder C 被动嗅探与所在主机交互的主机的操作系统版本等信息 Wireshark G 拦截经过指定网卡的所有流量 sectools常年排行第一的工具，这就不用多说了吧 proxy chains C官网无 好像用来配置多种代理的 Burp SuiteDNSCheffikedhamster-sidejackHexInjectiaxfloodinvitefloodiSMTPisr-evilgrade ohrwurmprotos-siprebind rtpbreakrtpinsertsoundrtpmixsoundsctpscanSIPArmyKnifeSIPpSIPViciousSniffJokeSSLsplitsslstripTHC-IPV6VoIPHopperWebScarabWifi Honey xspyYersiniazaproxy Password Attacks name mode function comment HexorBase G 一个支持多种数据库的客户端有多个数据库的口令破解功能 作为客户端只能将就着用。暴破口令需要自己准备字典 CeWL C 爬取给定的URL并依据限制条件截取网页中的单词生成口令集合 这种想法是可取的。但有点遗憾只是截取网页中的单词，没有a转@等等智能变换 crunch C 依据限定的条件生成口令集合 Hashcat C 多种hash的爆力猜解工具，速度快所耗CPU小（相对） John the Ripper C 用于对系统口令文件的破解（如/etc/passwd）还原出密码明文 Johnny G john的gui版本 medusa C官网无 可对IMAP, rlogin, SSH等进行口令猜解，类似hydra Ncrack C 可对IMAP, rlogin, SSH等进行口令猜解，类似hydra ophcrack G 基于彩虹表的windows口令破解工具 RainbowCrack C 具有彩虹表的生成、排序和使用排序好换彩虹表进行破解的功能 rcracki-mt C 基于彩虹表的hash破解工具，可能蚲rainbowcrack一部份 wordlists C 打印kali自带的一些口令文件存放的位置 mimikatz C官网无 用于从windows内存中提取密码 THC-Hydra 一款密码暴力破解软件可以在线破解多种密码需要配合强大的字典。密码能否破解就在于你强大的字典了。 BruteSprayBurp Suite chntpwcisco-auditing-toolCmosPwdcreddumpcrowbar findmyhashgpp-decrypthash-identifier keimpxMaltego TeethMaskprocessormultiforcer oclgausscrack PACKpatatorphrasendrescherpolenum RSManglerSecListsSQLdictStatsprocessorTHC-pptp-bruterTrueCrackWebScarab zaproxy Maintaining Access name mode function comment Intersect S 感觉是SQL 有攻击性Intersect语句的生成工具 Nishang C 基于powershell的后渗透攻击工具 PowerSploit C 也是一个基于powershell的后渗透攻击工具 Weevely S webshell连接工具不过好像要用自己生成的小马 CryptCatCymothoadbddns2tcpHTTPTunnel polenum pwnatRidEnumsbdshellterU3-PwnWebshells Winexe Hardware Hacking name mode function comment apktool C 从apk文件中还原出xml和图版等资源文件 dex2jar C apktool把apk还原成了资源文件和dex，dex2jar把dex还原成jar文件（.class） android-sdk Arduino Sakis3Gsmali Reverse Engineering name mode function comment edb-debugger G 软件逆向动态调试工具 Linux版Ollydbg flashm C官网无 .swf文件的反汇编工具可反汇编出.swf中的脚本代码 jad C dex2jar把文件还原成了.class，jad进一步把文件还原成.java文件 javasnoop G java程序漏洞评估工具 nasm-shell S nasm是32位汇编编译器，这是一个nasm的shell OllyDbg G windows平台大名鼎鼎的动态调试工具，Linux上是通过wine运行有点水土不服 radare2 C官网无 类似ida的静态反汇编分析工具，功能强大，开源 但是命令行操作这难度有点大 exe2hex C官网无 顾名思义就是把exe文件转成十六进制文件 不过这样的意义是什么，不是以十六进制就能打开了吗 apktooldex2jardiStorm3 JD-GUI smaliValgrindYARA Reporting Tools name mode function comment CaseFile G 一个画图工具，packet tracer用来画网络拓扑，这用来画场景拓扑 这写出高大上的报告啊 CutyCapt C 一个基于WebKit内核的网页截图工具，就是指定一个url它就能用解析url并把url界面截下来 各种扫描器中的截图就是使用类似的工具完成的，并不会真用个浏览器访问再截图下来 Dradis Web 可解析burpsuite/nmap等生成的扫描文件，并可将扫描结果转存为pdf或html MagicTree G 报告管理？？ pipal C 说词频统计并不是很准确，文命令可分析统计给定文件中的词语的“各种最” cherrytree dos2unix MetagoofilNipper-ng RDPY 其他 name mode function comment clang C 类似gcc的编译器，更轻量，可编译c、c++、Objective-C clang++ C C++编译器，与clang的关系类似gcc和g++的类系 keep note G 较之记事本，可建文件夹，支持富文本，可导出为其他格式 record my desktop C 屏幕录制，输出.ogv格式视频 不过感觉这视频格式占用磁盘有点大啊 hashdeep C官网无 用于计算文件hash值，支持多种散列算法 Social-Engineering S官网无 一般用于生成各种插入了exp的文件，诱使目标打开而中招 社会工程学总说得很厉害，不过我总觉得社会工程学和DDOS就是最名不副实的","tags":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/tags/hacker/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"categories":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/categories/hacker/"}]},{"title":"attack","date":"2019-04-12T06:24:00.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/hacker/attack/","text":"ARP投毒方式：欺骗目标机器，使其确信我们的攻击主机就是他的网关(假)，再伪装成目标机器欺骗网关(真)。这样所有的流量，都会通过我们的攻击主机，即可截获目标机器与网关(真)的通信数据 每个机器，都含ARP缓存，存储了本地网络中最近时间内MAC地址与IP地址的对应关系。 ARP投毒，就是对ARP缓存进行修改。","tags":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/tags/hacker/"}],"categories":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/categories/hacker/"}]},{"title":"net","date":"2019-04-12T06:24:00.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/hacker/net/socket/","text":"socketsocket-family-proto 变量 含义 AF_INET ipv4(family) SOCK_STREAM tcp(proto) listenbacklogThe backlog has an effect on the maximum rate at which a server can accept new TCP connections on a socket. error Socket error = #10060. 10060 is a Connection Time-out error that usually appears when the client does not receive a response from the server for a specific command","tags":[{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}],"categories":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/categories/hacker/"},{"name":"net","slug":"hacker/net","permalink":"http://yoursite.com/categories/hacker/net/"}]},{"title":"protocol","date":"2019-04-12T06:24:00.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/hacker/net/protocol/","text":"端口 Port Protocol 80 http 443 https 20, 21 ftp 22 sftp 110 POP3 143 IMAP 25 SMTP ARP地址解析协议Address Resolve Protocol ftp list of raw ftp commands ftp LIST FTP服务的LIST指令获取的文件列表信息的解析","tags":[{"name":"IP","slug":"IP","permalink":"http://yoursite.com/tags/IP/"},{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"},{"name":"ftp","slug":"ftp","permalink":"http://yoursite.com/tags/ftp/"},{"name":"sftp","slug":"sftp","permalink":"http://yoursite.com/tags/sftp/"},{"name":"POP","slug":"POP","permalink":"http://yoursite.com/tags/POP/"},{"name":"IMAP","slug":"IMAP","permalink":"http://yoursite.com/tags/IMAP/"},{"name":"SMAP","slug":"SMAP","permalink":"http://yoursite.com/tags/SMAP/"}],"categories":[{"name":"hacker","slug":"hacker","permalink":"http://yoursite.com/categories/hacker/"},{"name":"net","slug":"hacker/net","permalink":"http://yoursite.com/categories/hacker/net/"}]},{"title":"curl","date":"2019-04-08T14:15:58.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/curl/","text":"compile in Windows Visual Studio如果是静态编译，每次用libcurl时，还需要定义宏CURLPP_STATICLIB 好像也要用/NODEFAULTLIB:LIBCMT 包含的库的介绍官网 zlib解压zip文件解压解压 zlib minizip官方提供的处理zip文件 minizip-2 zipper封装minizip-2. libzip是封装后的，用于处理zip档案文件,使用范例 undeifned reference to symbol, 看见zip、inflate、defalte等函数名字，一般就是确实zlib的静态库 ssl参考-详细有效参考gist参考 123456789101112131415perl Configure VC-WIN32perl Configure debug-VC-WIN32 no-amsperl Configure debug-VC-WIN64Anmakenmake testnmake install# generate *.mak filems\\do_ms.bat# for static library in dirROOT/out32nmake -f ms\\nt.mak nmake -f ms\\nt.mak clean# for dll in dirROOT/out32dllnmake -f ms\\ntdll.mak VC-Win32, VC-Win64A(64位AMD), VC-Win64I(64位Intel), VC-CE(Windows CE)共生成4个文件夹 include lib bin 放dll和exe html 放文档 libcurl共支持如下模块SSPI,IPV6,IDN,WIN_SSL,SSL,SSH2,ZLIB等 Set RTLIBCFG=static这个会让编译器，用/MT和/MTd构建。 比如nmake /f Makefile.vc mode=static WITH_SSL=static DEBUG=yes MACHINE=x86 VC=11 GEN_PDB=no ENABLE_IPV6=yes 会在Root\\builds\\libcurl-******中生成，****是编译时的选项和添加的模块 2019.04.08的版本7.64.1目前需要先运行根目录下的buildconf.bat生成src/tool_hugehelp.c否则会编译报错 参考1参考2-详细有效参考3参考4参考5静态编译默认的命名配置 使用1使用2neon也可以其他类似库Windows-HTTP-WrapperWinHttp的UnsafeHeaderParsing CurlPP封装无需c++11支持 问题以下是Windows提供的库：报错内容常为LNK2001或LNK2019 需要IdnToAscii或IdnToUnicode这两个函数在Normaliz.lib中，功能是转换Internationalized Domain Name(IDN) 需要CertOpenStore等函数，在Crypt32.lib中 需要WSAStartup, WSACleanup等函数，在Ws2_32.lib中 需要ldap_init, ldap_memfree等函数，在Wldap32.lib中 注：crypt32.lib和ssl有关,这是个密码学库 需要curl_global_init, curl_version和curl_easy_setopt之类的，是libcurl.lib cpr封装 更贴近python的request 需要c++11支持","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"curl","slug":"curl","permalink":"http://yoursite.com/tags/curl/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"class","date":"2019-03-28T15:13:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/cpp/class/","text":"virtual, override 重载非虚函数和实现虚函数的区别 keyword virtual override interface interface principle boost interface Should C++ ‘interfaces’ have a virtual destructor 基类的析构函数必须析构，否则用基类指针时会不调用派生类析构 注：windows提供的interface关键词，还可以让VS支持一些判断校验，有点java的感觉。 抽象类、接口类与纯虚函数 纯虚函数 接口类 多重继承 static string class member 基本概念关于class中的const成员函数class HasPtr{ void Print(){} };如果我使用const HasPtr p1;p1.Print();编译器提示error: passing ‘const HasPtr’ as ‘this’ argument of ‘void HasPtr::Print()‘ discards qualifiers [-fpermissive]p1.Print ();但是如果我是class HasPtr { void Print() const{} };就不会出现这种情形，函数末尾的const是限定this指针的，我不懂为什么不可以 我现在遇到一个问题,写constructor,就是f(int a,int b){}f(int a,int b,char c){}他不让我通过,说什么b会在c之后initial,不懂啊…我找到问题了,原来我在private中定义他们的时候顺序是c,a,b,导致这个constructor就得按顺序.. 定义Constructor时,如果使用的是Constructor Initializer List,参见《C++Primer》P288-290我们在declared的时候就要写清parameters的名字,因为后面具体哪个元素的时候,我们需要指明我们用的是那个parameters的名字. constructor initializer List参见《C++Primer》P265正确格式是A(xxxxx): a1(xxx), a2(), a3(xxxxx) {} 对于const class DataMember这似乎是唯一一个可以不用在declare时initialize的const变量，但是必须在constructor中使用initializer list的方式，而不是在constructor里面用assignment方式！！！想请参见const data member can not call member function without object如果这个member function是static就没问题了，可以直接用class type class的protected级别究竟何意？ no matching function for call to ctor()当使用xxx i1;定义一个变量时。如果定义了一个ctor(xxx)，好像compiler不会帮你自动生成ctor() invalid use of member’xxxx’ in static member functionxxxx必须是static变量才行！！error: undefined reference to `xxxx’error: ISO C++ forbids in-class initialization of non-const static member!!! 要用作root of an inheritance hierarchy的class一定要定义一个virtual destructor 即 virtual ~class_name()=default; Constructor中explicit的用法，以及具体用途显示转换explicit conversion和隐式转换implicitly convert，详情见忠告15？？？ 根据目前所知的，隐式转换,比如class T1变成 class T2,一共两种办法：第一种：a type conversion function in class T1(e.g.,operator T2)第二种：a non-explicit constructor in class T2 that can be called with a single argument 显示转换：If you wish to allow explicit conversions only, you’ll want to write functions to perform the conversions,but you’ll need to avoiding making them type conversion operators or non-explicit constructors that can be called with one argument.他和无参数的constructor应该是没什么关系，只要我们定义了带argument的ctor，并且没有“显式”的定义no argument的ctor，那么编译器就会警告我们当我们调用no argument的ctor，编译器绝对不会替你去实现no argument的ctor！！！！！！！！ explicit问题在muduo的线程库Thread.h中一个函数声明如下explicit Thread(const ThreadFunc&amp;,const std::string&amp; name=std::string());有人怀疑这个explicit的意义，因为explicit关键字进制隐式转换在构造函数参数大于或等于2时无效。作者的回复是，有意义，自己写个程序对比一下即可知道。 两个class互相调用彼此成员函数出现了以下问题error: invalid use of incomplete type ‘class Folder’void save (Folder&amp;x){ f.insert (&amp;x); x.addMsg(*this); }error: forward declaration of ‘class Folder’目前的解决办法是A.h#ifndef AH#define AHclass B;class A{}#endifB.h#ifndef BH#define BH#include&quot;A.h&quot;class B{}#endifA.cpp#include&quot;A.h&quot;#include&quot;B.h&quot;在这里A可以使用B的成员函数 error “uses undefined struct”","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"class","slug":"class","permalink":"http://yoursite.com/tags/class/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"cpp","slug":"编程语言/cpp","permalink":"http://yoursite.com/categories/编程语言/cpp/"}]},{"title":"keyword","date":"2019-03-28T14:13:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/cpp/keyword/","text":"typedeftypedef这种别名,贯穿header文件始终,放在最前面 typedef array问题方法一：typedef char type24[3];定义的类型为array type，但是users of it won’t see that it’s an array type. If used as a function argument, it will be passed by reference, not by value, and the sizeof for it will then be wrong.方法二：typedef struct type24{ char x[3]; } type42; inline定义一些一句话函数inline或者我暂时还不大懂的constexpr,尽量在hearder里面这么做.inline表示的是,他不是调用该程序,是直接替换函数名,用函数体,增加效率 static 函数名前面加static是啥是意思? extern tells the compiler that the variable is defined somewhere else, so it doesn’t complain about it being undefined 特殊用法#ifdef _cplusplusextern &quot;C&quot; {#endif......#ifdef _cplusplus}#endif用途是extern “C” makes a function-name in C++ have ‘C’ linkage (compiler does not mangle the name) so that client C code can link to (i.e use) your function using a ‘C’ compatible header file that contains just the declaration of your function. Your function definition is contained in a binary format (that was compiled by your C++ compiler) that the client ‘C’ linker will then link to using the ‘C’ name.Since C++ has overloading of function names and C does not, the C++ compiler cannot just use the function name as a unique id to link to, so it mangles the name by adding information about the arguments. A C compiler does not need to mangle the name since you can not overload function names in C. When you state that a function has extern “C” linkage in C++, the C++ compiler does not add argument/parameter type information to the name used for linkage. 详情见extern “C”extern in cpp const const问题!!!top和low的区分!! 函数使用vector时,如果我们不对它修改,一定要加上const,而且尽量用”const引用”这种方式!!!!这样能极大地减少程序开支 enumenum枚举声明","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"keyword","slug":"keyword","permalink":"http://yoursite.com/tags/keyword/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"cpp","slug":"编程语言/cpp","permalink":"http://yoursite.com/categories/编程语言/cpp/"}]},{"title":"mfc","date":"2019-03-26T15:15:58.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/mfc/","text":"MFC和GDImfc font weight GDI+和GDICBitmap和HBITMAP HBITMAP、BITMAP、CBitmap load pngload jpg pngload png resource using gdiload image from resource using gdidraw a png image using loadimage and stretchDIbits 加载图标，亲测可行HBITMAP h=LoadBitmap((HINSTANCE)GetWindowsLong(hWnd, GWL_HINSTANCE), MAKEINTRESOURCE(IDB_xxx)) GDI+字体 clear paint清空之前的绘制 MFCMFC类对应的头文件 mfc碰见IDD_...的undecalared identifier直接#include&quot;resource.h&quot; 自绘控件总结 图标mfc程序添加图标 注：debug模式没有，release模式才有win32的console程序添加图标 win32添加图标 对话框mfc两种类型“文件对话框” mfc两种“对话框”，模态、非模态 mfc的IsWindow的用途，如果别的控件让该控件EnableWindow(false)，该如何捕获该事件？且似乎会阻塞消息。 dialog reopen destroy dialog 对话框背景颜色 不规则边框亲测可行 1234 透明1 GDI+gdi+ 事件OnPaint和WM_CNPAINTOnPaint和DrawItem GetDlgItem(IDC_XXX).EnableWindow()和xxx.EnableWindow(true/false)可以适用于任何控件，对话框、按钮等等。 鼠标事件mfc的tackMouseEvent中的tme_cancel到底怎么和tme_hover/leave来配合的？？ 123456 鼠标位置鼠标是否在框内鼠标在控件内 浮窗显隐浮窗显隐2 MFC的帮助类CStringthat uses a CString-derived class from a DLL file 12345CString hi(\"HI);std::wstring wHI(hi);std::wstring hi(L\"HI\");CString cHI(hi.c_str()); 宽字符转utf8 ATL::CW2A(str, CP_UTF8)宽字符转ansi（默认） ATL::CW2A(str) CFtpConnection CFtpConnection CFtpConnection msdn CFtpConnection command CFontCFont字体Cfont","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"mfc","slug":"mfc","permalink":"http://yoursite.com/tags/mfc/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"imgui","date":"2019-03-25T15:15:58.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/imgui/","text":"评价 很好用的gui库，特别适合做小工具。 和direct3d有点关系，可以学到些GameProgramming的概念 网上资料不多，主要是作者在github上不停的答issue，真是个精力旺盛的人。 本质还是个C，只用到了些许cpp的特性。 作者的example是个大宝库，可以学到很多有意思的范例 优秀范例 use ImGui with SFML 例子 imgui只支持utf8 inputtext文字输入虚拟按键 multiline不是真的多行，而是该控件可以识别\\n显示文本，不要想着用std::vector&lt;std::string&gt;，别把char*[]想太多。 inputtextmultiline inputtextmultiline封装 imgui_input_text_multiline_for_std_vector ImGuiTextEditState 这个还支持callback能实现很酷的效果。cpp的std引入 疑问：##用在label中是什么含义？？ ImGuiInputTextFlags_ReadOnly begincombo和endcombo用来实现selectBox1 Columns用来做表格，元素既可以是text也可以是textinput，总之是个很灵活的GUI库 API","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"imgui","slug":"imgui","permalink":"http://yoursite.com/tags/imgui/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"std","date":"2019-03-25T14:13:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/cpp/std/","text":"综述 History of C++ CppCon2014 std::string std::replace replace all occurance string char转wchar_t解决方案 char* 和 std::string和char[]比较 string occurance string is number strcmp char转string1234//char -- std::stringchar c;std::string s(1,c);std::string s(15,c); char array转string1 Defining a string with no null terminating char(\\0) at the end printf与char*与string安全性 std::memcpy和std::memcpys这个对于cpp只适用于POD。 文档 POD解释 和string配合时，往往要len+1，否则\\0没地方放，会出现严重问题 拼接字符串当你用C-style的string时,我们想要将s1和s2相串联,必须要s1+&quot; &quot;+s2,不能是s1+s2,前者是分两步的,必须是双引号,单引号是char不是string类.第一步,s1+&quot; &quot;他的结果是string类,然后再用这个string类+s2,也就是说虽然C++可以将旧的C-style相加,但是必须得保证至少有一个是string类毛线,不行,必须都得是stirng类…简直扯淡. 分解字符串1 pad，前面还是后面补足到某一固定长度1提供了下述方法：(1)std::setw配合std::sstringstream(2)std::string::insert()和std::string::append()(3)std::setfill container 所有的std的API中，关于iterator都是[begin, end) 使用container时,&lt;&gt;中间如果你想用C-style的string,你只能用const char*,这个const是不能省略的!!! 学会用C++11的Range for Statement。参见《C++Primer》P187for(auto ch:s)或者for(const auto&amp; r:v) 溢出 vector若是使用v[20]即使v.size()==19他也会输出值，且不会报错！！这特别的危险！！！ vector和string使用iterator时,不要忘记判定是否超出限制边界!条件语句里尤为重要!! 有时候我们会采用C的[]方式，来提取元素值，很可能就忽略了，合理性检查，譬如vector，string，map等 对于stack，不要盲目top()或是pop()，很可能忽略了empty()检查！！！ 如果我们把错误的begin和end给了algorithm的min或max之类的函数，他们不一定会给我们返回正确的数值，他们根本不会去检验你的iterator的正确性！！！！比方说，你想在vector发生删除操作后，更新min_ele，要是vector此时恰好为空，那真是就爆炸了，你的min_ele压根不会更新，还是之前的数值！！！ 上述都是忽略了合理性检查，而std他可是不会管你的，直接死在那里，程序动都不动的。 vecotr vector的一个教训，copy ctor不仅仅是在copy时会调用！！！vector.push_back()若是原来的容量不足，就会发生大范围的整体搬迁，然后就会隐含copy ctor这个调用！！他不仅仅是vector还有T，都会调用！！所以当定义的class（将其作为T)中，主动将copy ctor=delete且move ctor=delete时，就会导致push_back可能会失败 resize和reserve用途 std::unoreder_setThe value of ESP was not properly saved across a function call.This is usually a result of calling a function declared with one calling convention with a function pointer declared with a different c 这是因为只有元素能被hash的，才可放在unordered容器中。所以如果硬要放，你得做一些适当的修改 map map::insert vs [] 常见领域std::priority_queue可以修改后做固定数目的min_heap或max_heap即小根堆、大根堆。std::deque有双向iterator，当你相让std::queue拥有std::vector性质时，可以考虑用他 类型 特点 实现方式 vector 单向开口、连续线性 连续线性空间，配置新空间总会预留一部分用于“成长”，如果还不够，就会另觅更大空间+复制原数据+释放原空间 list 双向链表 空间运用绝对精确 deque 双向开口、连续线性 一段一段的定量连续空间构成（分段连续），所以需要中央控制，以造成整体连续的假象 queue FIFO、队列 default使用deque实现，也可用list stack FILO、栈 default使用deque实现，也可以用list，vector algorithm检查某一元素std::find_if std::accumulate使用algorithm中的accumulate时,第三个量var,也就是sum的初始值,也要求和前两个量所指向的内容一致,最坑的就是vector,如果var你设置成0,它会把你前面的指向的double全变成int resource managershared_ptr定义deleter 是否有必要在二叉树这种多指针，使用SmartPointer这个工具 是否可行，定义vector&lt;unique_ptr&lt;T&gt;&gt;，是否可知执行push_back(raw pointer) other std::cout的多线程本质stdout也是个io-fd，也会存在竞争。using-stdcout-in-multiple-threads New–funtional programming std::function&lt;&gt;实现了一套类型消除机制，可以统一处理不同的函数对象类型（普通函数（包括成员函数）、Lambda表达式、函数指针、以及其它函数对象functor等）。以前我们使用函数指针来完成这些；现在我们可以使用更安全的std::function来完成这些任务。 std::bind()与std::function&lt;&gt;搭配一个用法为，取代虚函数virtual function。即实现：同一个class，不同的object，某个API有不同的实现方式，从而实现不同的行为。具体参考《linux多线程muduo》第11.5节阐述std::function&lt;&gt; f1=std::bind(&amp;X, this)这个用法和python的class中self概念有些相似 使用lambda取代std::bind error_code这是从boost引进的，c17才添加。 std::error_code Your own error code boost-system-error boost::error_code stream cout、cerr、clog的区别 ostream ifstream和ofstream文件流。 获取长度。或者 std::ifstream.clear/seekg/tellg/ std::ifstream::ate/binary, std::ios::beg ostringstream和istringstream和stringstream不要对std::string有偏见，的确他的c_str()会在\\0处结束，但是内部的内容却是完整的，完全可以用data()匹配char*, length()匹配len来作为buff或char数组。千万不要只用一个data/c_str，对于非文本内容绘有截断，比如加解密的结果，二进制文件内容等。 ostringstream stringstream stringbuf task C++ Task Scheduler enkiTS 自己实现的 自己实现 RIOS Implementing a lightweight task scheduler in C++ Concurrency-Runtime-in-Visual-C-2010","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"std","slug":"std","permalink":"http://yoursite.com/tags/std/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"cpp","slug":"编程语言/cpp","permalink":"http://yoursite.com/categories/编程语言/cpp/"}]},{"title":"python-grammar","date":"2019-03-24T22:57:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/python/grammar/","text":"字典使用os.environ.get(&#39;GMAIL_USERNAME&#39;)不会报错“raise KeyError(key) from None” 而os.environ[&#39;GMAIL_USERNAME&#39;]就会报错。后者我觉得C++这么写比较好，图省事，但python不推荐。 字符串用双斜杠作为转义字符，来转义单引号 字节数组转字符串 iterate bytes bytes()和b prefix string to bytes concatenate byte strings concatenate multiline strings python int to hex string python Repeat string Python（字节数组bytearray Python 字节与字节数组 Python 中的字符串&amp; 字节和字节数组 python3.2的bytes和str数据拼接 Can’t concat bytes to str pad string to fixed length python实现substring截取子字符串 bytes hex-string format format integer dec to hex format 转换 ord()是chr()/unichr() int to ascii—ord 规矩 python不允许一个文件名叫app.py,无法识别。 py文件名不要有-，否则无法import python的方法前面 _ _表示private方法 python3的import只能这样写，同文件夹的modulefrom . import xxxfrom .xxx import yyy这样写都没用，py3的相对导入就是个坑，不要试图去尝试。下列答案都没法解决http://kuanghy.github.io/2016/07/21/python-import-relative-and-absolutehttp://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p03_import_submodules_by_relative_names.htmlhttps://www.oschina.net/question/1475764_229144https://segmentfault.com/q/1010000000263255https://stackoverflow.com/questions/1896918/running-unittest-with-typical-test-directory-structure/24266885#24266885用绝对导入，还报错，就再多写一层 exception异常处理 官方文档 初学者 python exception message capturing if if x is not None None output 同时输出到console和file 重定向file signal中断signal.SIGINT 定时框架Python 定时任务的实现方式","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"grammar","slug":"grammar","permalink":"http://yoursite.com/tags/grammar/"},{"name":"language-habit","slug":"language-habit","permalink":"http://yoursite.com/tags/language-habit/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"python","slug":"编程语言/python","permalink":"http://yoursite.com/categories/编程语言/python/"}]},{"title":"python 2.7&3.5","date":"2019-03-24T22:57:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/python/py2 & py3/","text":"2和3的语法差别 Porting Python 2 Code to Python 3 Porting Python 3 xrange和range unicode()和str() hex-dumppy2和py3实现略有区别 python-3-x-hexdump v2 v1 2.7和3的兼容版","tags":[{"name":"python2.7","slug":"python2-7","permalink":"http://yoursite.com/tags/python2-7/"},{"name":"python3.5","slug":"python3-5","permalink":"http://yoursite.com/tags/python3-5/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"python","slug":"编程语言/python","permalink":"http://yoursite.com/categories/编程语言/python/"}]},{"title":"python-xpath","date":"2019-03-21T14:57:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/python/library/xpath/","text":"xpathxpath语法 1234//ul/li/a/@href//div[@class='page']/a[last()-1]/text()//div[@class='content']/a/img/@src//h2/text() ctrl+shift+J谷歌看网页源代码在该界面下，ctrl+F支持selector、xpath语法来搜索。在该界面下，搜索“//input”,”//textarea”,就可以找到你所有需要提交的form的filed的name。 xml encode xml by escape Escaping strings for use in XML lxml使用 generate xml","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"},{"name":"lxml","slug":"lxml","permalink":"http://yoursite.com/tags/lxml/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"python","slug":"编程语言/python","permalink":"http://yoursite.com/categories/编程语言/python/"},{"name":"library","slug":"编程语言/python/library","permalink":"http://yoursite.com/categories/编程语言/python/library/"}]},{"title":"python-os","date":"2019-03-21T14:57:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/python/library/os/","text":"processSubProcess.call()在windows环境执行问题To quote from the documentation:The only time you need to specify shell=True on Windows is when the command you wish to execute is built into the shell (e.g. dir or copy).You do not need shell=True to run a batch file or console-based executable. winreg操作windows的注册表 windll12KERNEL32 = windll.LoadLibrary('')FUNC = windll.kernel32.GetProcAddress(KERNEL32, '') 具体示例 os.pathos.path.join(path, *paths)Join one or more path components intelligently.The return value is the concatenation of path and any members of *paths with exactly one directory separator (os.sep) following each non-empty part except the last, meaning that the result will only end in a separator if the last part is empty. If a component is an absolute path, all previous components are thrown away and joining continues from the absolute path component. On Windows, the drive letter is not reset when an absolute path component (e.g., râ€™\\fooâ€™) is encountered. If a component contains a drive letter, all previous components are thrown away and the drive letter is reset. Note that since there is a current directory for each drive, os.path.join(&quot;c:&quot;, &quot;foo&quot;) represents a path relative to the current directory on drive C: (c:foo), not c:\\foo. os.path.isdir(path)Return True if path is an existing directory. This follows symbolic links, so both islink() and isdir() can be true for the same path. os.mkdir(path [ , mode ] )Create a directory named path with numeric mode mode.The default mode is 0777 (octal). On some systems, mode is ignored. Where it is used, the current umask value is first masked out.If the directory already exists, OSError is raised.It is also possible to create temporary directories;see the tempfile moduleâ€™s tempfile.mkdtemp() function. Availability: Unix, Windows.","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"},{"name":"os","slug":"os","permalink":"http://yoursite.com/tags/os/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"python","slug":"编程语言/python","permalink":"http://yoursite.com/categories/编程语言/python/"},{"name":"library","slug":"编程语言/python/library","permalink":"http://yoursite.com/categories/编程语言/python/library/"}]},{"title":"qt","date":"2019-03-21T14:13:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/qt/","text":"问题qt nmake link.exe 0x463 error c2079 use undefined struct nmake fatal error u1077 return code ‘0x2’ 用vs2010编译qt库，然后qt-creator使用vs2010加已编译成功的qt-lib，来nmakeconfigure -static -commercial -opengl desktop -no-angle -qt-libjpeg -qt-libpng -make libs -make tools -no-compile-examples -nomake tests -nomake examples -platform win32-msvc2010 windows环境配置编译报错 main–入口函数main, WinMain QT-Creator界面左边的”Project”可以看到Build-Directory, Build-steps, Clean-steps, Build-Environment等信息。 qmake会生成MakeFile、MakeFileDebug、MakeFileRelease这3个文件，和Debug、Release两个目录等内容，该内容在Build-Directory中 MakeFile包含需要编译哪些文件，编译选项等信息，类似VS的.projvcx+.sln。 每次ReBuild、Build并不会把这3个MakeFile给重置，所以需用自己手动删除掉整个Build-Directory内容，否则经常会报错什么无法解析的外部符号(LNK2019)等。 MakeFile是由.pro再加上......\\QT\\5.6\\msvc2015_64\\mkspecs\\win32-msvc2010\\qmake.conf和......\\QT\\5.6\\msvc2015_64\\mkspecs\\common\\msvc-desktop.conf等配置。文件中预置的变量QMAKE_LIBS_CORE等都很有参考价值一般通过修改.pro即可。 .pro个性化内容 123456789101112131415161718192021WIN32:LIBS += LIBS += ws_2s.lib \\ -L&quot;C:/Program Files(x86)/Windows Kits/&quot; -lkernel32INCLUDEPATH += $$VAR#macrosDEFINES += UNICODE _UNICODEDEFINES -= _MBCSDEFINES += _AFXDLL #MFC#cpp compile flagQMAKE_CXXFLAGS += -std=c++0x#c compile flagQMAKE_CFLAGS += -std=c99#link flagQMAKE_LFLAGS += /NODEFAULTLIB:msvcrt.lib build-environment很重要，尤其是里面的LIB, INCLUDE,PATH这3个变量。 qt Specifying Build Settings qt pri libraryQSTRING1234567891011121314151617181920212223// formatQString(\"%1/%2-%3.txt\").arg(1,\"Tom\", 'a');QString str;str.sprintf(\"%s %d\", \"Tom\", 1);// std::string-----》 QStringstd::string s=\"123\";QString qs = QString::fromStdString(s);QString qs = QString::fromLocal8Bit(s.c_str()); // ANSIQString qs = QString::fromUtf8(s.c_str()); // utf8QString qs = QString::fromUtf8(s.data(), s.length());// QString-----》std::stringQString qs = \"123\";std::string s = qs.toStdString();std::string s = qs.toLocal8Bit().constData(); // ANSI(Windows)std::string s = qs.toUtf8().constData(); // utf8// QString---const char*----CString xml Format XML file in c++ or Qt How to Format XML Files in C How can I read an XML file into a buffer in C? QML我记得有个人论断，gui就是像html那样用描述性语言才是他的终极形态。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"qt","slug":"qt","permalink":"http://yoursite.com/tags/qt/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"template","date":"2019-03-20T14:13:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/cpp/template/","text":"1模板了解类型推导 问题二：在哪里定义类的成员模板函数cpp官方解释文档方案一方案二 问题三：”Missing ‘;’ brefore ‘template&lt;’”解决方案 不定参数模板qt解决方案 Basic–Template invalid use of template-namexxx without an argument listtemplate&lt;typename T&gt;xxx&lt;T&gt;::xxx(){}必须如此 need typename before xxxx, because xxxx is a dependent scope问题一般出现在内嵌型别，这在泛型编程重特别普遍 undefined reference to xxxx问题出现在initialization template因为我们是在header中declare，在cpp中再define解决办法： 方法一：最好的最常见做法就是在header中完成declare和define的全部内容！！不存在cpp 方法二：xxxx.cpp变成xxx_impl.h,然后再project也将其include进去 方法三：在xxx.h或xxx.cpp中将其instance，而且必须带类型，代价就是无法自动扩展，灵活性极低，失去了泛型的意义。Template class的member function是template Return ClassName&lt;XXX&gt;::FuncName();class的member Template function是template Return ClassName::FuncName&lt;XXX&gt;(); template格式书写声明：template&lt;typename T&gt;class MyCls { void f(); };定义： 错误 void MyCls::f() {} 错误 template&lt;typename T&gt; void MyCls::f() {} 正确 template&lt;typename T&gt; void MyCls&lt;T&gt;::f() {} 偏特化 template specializationtemplate_specializationDifference between instantiation and specialization 函数模板函数模板官方文档 函数模板 实例化和具体化Explicit Specialization of Function TemplatesExplicit Template Function and Method Specialization","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"template","slug":"template","permalink":"http://yoursite.com/tags/template/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"cpp","slug":"编程语言/cpp","permalink":"http://yoursite.com/categories/编程语言/cpp/"}]},{"title":"windows-cpp","date":"2019-03-20T14:13:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/cpp/windows/","text":"vcpkg windows官方的github 软件安装工具 1234567891011121314151617181920&gt; git clone https://github.com/Microsoft/vcpkg.git&gt; cd vcpkgPS&gt; .\\bootstrap-vcpkg.batPS&gt; dir Env:VCPKG_ROOTPS&gt; setx VCPKG_ROOT \"\"PS&gt; setx VCPKG_DEFAULT_TRIPLET=x64-windowsPS&gt; .\\vcpkg.exe helpPS&gt; .\\vcpkg.exe search curlPS&gt; .\\vcpkg.exe install sqlitePS&gt; .\\vcpkg.exe listPS&gt; .\\vcpkg.exe install zlib:x64-windowsPS&gt; .\\vcpkg.exe upgrade --no-dry-runPS&gt; git pullPS&gt; .\\bootstrap-vcpkg.batPS&gt; vcpkg version pragma What does #pragma intrinsic mean? #pragma编译指令大全（上） #pragma编译指令大全（下） #pragma命令详解 #pragma命令详解(一) #pragma命令详解(二) 不同版本dll 让.NET程序兼容不同版本的Dll文件 dll向后兼容 针对同一动态组件的不同版本链接和加载 解决dll兼容性问题 一个项目引用不同版本dll dll版本兼容 动态加载、插件化、热部署、热修复 vs2010的c+11 features c11-features-in-visual-studio-2012 initializer-list-not-working-with-vector-in-visual-studio-2012 c14才有make_unique，所以vs2010只能是用 12std::unique&lt;Base&gt; p;p = std::unique&lt;Derive&gt;(new Derive); atomic system.threading.interlocked atomic性能比较 boost.Atomic的windows适配就使用下面这个实现 interlocked-variable-access std::atomic C++11标准中的Atomic原子操作和内存模型 注：unsigned long long/int64他们默认调用64bit版本的API，然后就导致在XP32上会报interlockedcompareexchange64 could not be located kernel32.dll。而且and/or/xor的API只有64位版本。具体说明 windows自定义的integer type别名__int64 与long long 的区别 stdio.h的safe提供的_TRUANCATE宏_TRUANCATE vs多工程多工程开发 windows中常见的函数修饰_stdcall, _cdecl_stdcall windows自己实现的并行容器 concurrent-unordered-map concurrency-namespace concurrent-hash-map比较 lock free map问题 lock free map论文 Windows的大牛Jeffrey Richter 一些讨论mfc-win32-核心编程 vs2010入门级使用—gtest教程 时间 SYSTEMTIME Windows中的时间(SYSTEMTIME和FILETIME) Windows系统时间(FILETIME和SYSTEMTIME Windows 各种计时函数总结 cmd用system() windows.h和afx(mfc) windows-h-and-mfc windows-h-and-mfc关系 stdafx.h的作用 StdAfx.h的理解，最下面解决了为什么会报错undeclared identifier 宏编译 预处理头 ，经常可以在stdafx.h文件中出现宏定义#define WIN32_LEAN_AND_MEAN，具体含义就是当项目中包含#include&lt;windows.h&gt;时去除一些头文件的包含。一个重要的演示例子就是winsock2.h和windows.h之间有关于_WINSOCKAPI_的重复定义，如果定义了上面的宏编译，就会避免出现重定义，不同的链接的错误。 stdafx.h、sdkddkver.h等 “Error: Windows.h already include. MFC apps must not #include&lt;windows.h&gt;”当时是在h文件添加include，后来改为cpp文件就没问题 msdn论坛建议 在编译VC++6.0是,出现fatal error C1010的错误 fatal error C1010: unexpected end of file while looking for precompiled header. Did you forget to add ‘#include “stdafx.h”‘ to your source? fatal error C1010: unexpected end of file while looking for precompiled header directive 解决方法： 如果发生错误的文件是由其他的C代码文件添加进入当前工程而引起的，则Alt+F7进入当前工程的 Settings，选择C/C++选项卡，从Category组合框中选中Precompiled Headers，选择Not Using Precompiled headers。确定。 在cpp文件开头添加: #include &quot;stdafx.h&quot; 对预编译头文件说明如下： 所谓头文件预编译，就是把一个工程(Project)中使用的一些MFC标准头文件(如Windows.H、Afxwin.H)预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。 预编译头文件通过编译stdafx.cpp生成，以工程名命名，由于预编译的头文件的后缀是“pch”，所以编译结果文件是projectname.pch。即pre-compile-header缩写 编译器通过一个头文件stdafx.h来使用预编译头文件。stdafx.h这个头文件名是可以在project的编译设置里指定的。 编译器认为，所有在指令#include &quot;stdafx.h&quot;前的代码都是预编译的，它跳过#include &quot;stdafx. h&quot;指令，使用projectname.pch编译这条指令之后的所有代码。因此，所有的CPP实现文件第一条语句都是：#include &quot;stdafx.h&quot;。 MFC 跟win32的比较【其实做这是在和GDI/Direct作比较】 From colleague: Win32 Release 出来的Image 小 Win32细节控制更强，因为MFC的封装，有些功能想要修改反而比较麻烦 Win32移植更加方便（例如移植到WINDOWS MOBILE平台） From Internet: 看法一：win32有两种执行程序，一种是控制台程序，没有图形界面的，另一种是windows图形界面的GUI程序，就是可以打开窗口，在窗口中画图显示文字的程序 win32 sdk还可以编写dll MFC是一个类库，用这个类库编写windows图形界面的GUI程序比较容易，但生成的exe文件比较大。 现在很少有直接用win32直接写GUI程序，除非程序很简单，要求程序很小的情况。一般都用MFC，这样可以用相同的时间写出更漂亮和复杂的GUI程序。 看法二： WIN32 是Windows的一个子系统，也是最重要的一个。（还有POSIX子系统和OS/2子系统）Win32子系统为应用程序提供了使用系统资源的接口Win32 API，WIN32 API是Windows用户态下应用程序编程的基础。因此所有在WIN32API基础上的应用程序都是Win32应用程序。 MFC ，Microsoft Foundation Classes.微软基础类库。这个类库不光封装了大多数的GUI系统对象和数据结构，还为开发者提供了开发框架，使原本复杂繁琐的Windows开发（尤其使界面开发）变得非常简单。MFC是对API的封装，因此它能实现的功能只是API的子集。对于追求系统底层相关而且效率高的程序而言，MFC不够灵活而且开销也大。但对于图形界面开发，如果没有MFC而使用API的话那么开发简直是对人的折磨。MFC很好用，但终归也是API的东西。懂了系统原理和接口，MFC也就全明白了。 看法三： win32是windows下的最基本的编程方式，使用它得到的代码最干净最有效率，也是最底层，它是其它所有方式实现的基础。一般指只使用API和SDK。 MFC是对win32的封装，使用win32编程方法，写了一个又一个类，让我们不用再重复大量劳动。但毕竟是封装，所以不可能完全实现win32所有功能。用着虽然方便，但距离细节毕竟远了，在个性个、特殊化方面还有差距。 两者相比，win32更本质,MFC更抽像。从软件工程来看，MFC更符合要求，更人性化。我们在正常使用中，优先使用MFC MFC的功能正常情况下可以满足绝大部分的需要，特殊需要，也可以直接用API和SDK实现。但反过来，win32下想用MFC的东西，却是非常困难的。MFC下开发，是包融了win32. MFC和vc融合，拥有大量人性化的东西，会极大增加开发效率。如界面、通用对话框等。而且它的代码是微软写的，比你自己用win32实现更值得让公司信赖。而且代码量会降低很多，更容易调试和维护。 很多功能你自己实现起来非常麻烦，甚至你的技术没达到那标准，而使用MFC很简单，这会迫使你使用它。 有些场合下不要使用MFC： 三维游戏等，这些东东MFC并没有包含，这时需要使用其它库。使用MFC反而不好，会造成臃肿和拖累。 特殊程序，如病毒等后台工具。它们根本不需要什么界面，需要的就是效率，而且要求体积小。这些无疑Win32比MFC强，甚至连win32都可以不用。 简单的实现，win32上简陋的东西就够用了，或者就算不够用，但有STL等C++自带的，那么MFC就可以不需要了。win32更符合老编程员的习惯。而且如STL，同样功能下，事实上比MFC更优秀。 winsockrecv超时时间设置 registry winAPI设定registry registry-functions SetEnvironmentVariable的msdn文档 RegQueryValueEx RegQueryInfoKey Enum Registry pipeNamed Pipe 模块 dll libGetModuleHandle报错 the specified module could not be found 很可能是因为该dll目前没有一个进程有加载到内存中，那就需要我们自己LoadLibrary 也很可能是因为32/64bit缘故 也可以用PathFileExists来判断dll文件是否存在 编译报错问题一 LINK : fatal error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏NMAKE : fatal error U1077: “”C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\BIN\\x86_amd64\\link.EXE””: 返回代码“0x463” 问题说明：当安装VS2012之后，原来的.NET 4.0会被替换为.NET 4.5。卸载VS2012时，不会恢复.NET 4.0。 l 当VS2012安装后，VS2010的cvtres.exe就无法使用了。如果你的PATH环境变量中VS2010的工具路径第一个出现，而且链接器需要将.res文件转换为COFF 对象格式，就会导致LNK1123错误。l 当VS生成PE文件头时，使用的cvtres.exe版本错误，不能与当前的.NET平台兼容。解决方案： 参考 因为是cvtres.exe版本错误导致的结果，所以凡是能使VS链接器找到正确的cvtres.exe版本的方法都可以解决该问题。或者使VS链接器不生成COFF的方法都可以。 【方法一】 当前系统中存在两个cvtres.exe文件，版本不同。让VS2010使用.NET 4.5的cvtres.exe程序。 具体步骤： 重命名或删除：（vs2010安装的位置）C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\cvtres.exe 这样C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319 (.NET 4.5)中的cvtres.exe文件就可以被VS2010使用。 【方法二】解决方法如下：项目\\属性\\配置属性\\清单工具\\输入和输出\\嵌入清单：原来是“是”，改成“否”。 说明：这种方法每个工程均需要修改配置。 【方法三】安装：VS2010 SP1. 该版本应该是能使用.NET 4.5的，并配有正确的cvtres.exe版本。 注意：安装VS 2010 SP1 时会移除64-bit 编译器. 通过安装 VS 2010 SP1 compiler pack 能够重新获得。 【方法四】卸载.NET 4.5，重装.NET 4.0 问题二是个常见的header导致的错误 问题三C语言奇怪的VS编译报错C2059, C2061 unknown override specifier, missing type specifier【与stdafx.h这个预编译header，没有关系。只要保证cpp中的第一行是stdafx就可以】这个问题，主要是由于我的依赖header是通过vx添加的，导致依赖覆盖。举例，&lt;windows.h&gt;就可以完成&lt;winbase.h&gt;和？？？。 【msdn的超长错误表https://msdn.microsoft.com/en-us/library/8x5x43k7.aspx?f=255&amp;MSPPError=-2147217396】 #pragma comment(lib,&quot;Mwic_32.lib&quot;) #pragma once remote access—fatal error 1 2 ? wsaGetLastError和GetLastError区别 Why does the function WSASetLastError exist std::system_error和GetLastError libcmtd.lib libcpmtd冲突 windows char to wchar CT2A和CA2T #pragma comment(linker /section:.rdata) 关于#pragma comment(linker, “/Section:Shared,rws”) loadlibrary VirtualAlloc VirtualAlloc(msdn) loadlibrary和getmodulehandle区别 loadlibrary和getmodulehandle 文件 命令ls的功能 How to check if directory exist using C++ and winAPI windows - How can we check if a file Exists What is the Win32 API function to use to delete a folder CreateFile() Failed With GetLastError() = 5 ::createFile winApi fails with error 5 Windows-CreateFile How to Read file from a shared location Windows How to list the Files in a Directory in C++ How to check if directory exist using C++ and winAPI How to list files in a directory using the Windows API? MoveFile, MoveFileEx, CopyFile的几点心得 Local File Systems(包含了很多) CreateDirectoryA function MoveFile function Windows Overlapped I/O详解 CreateFile,ReadFile等API详解 msdn opening a file for reading or writing File Attribute Constants createfilea How to get a folder size via Windows API How can I find the size of all files located inside Size of a directory How to flush all file buffers in Windows MSXML Which version of MSXML began to support parsing xml1.1 Character reference “&amp;#x1F” is an invalid XML character Invalid characters for XML parsing in posthistory.xml concurrency Mutex Objects Using Mutex Objects disk info win API get disk info cmd get disk info Calling DeviceIoControl 任务框架 Task Scheduler 同步原语 TimerQueue timeSetEvent timeSetEvent docs) How to schedule a task in C++ 字符串 BSTR, _bstr_t, SysAllocString, WCHAR and Passing Parameters to WMI Methods","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"cpp","slug":"编程语言/cpp","permalink":"http://yoursite.com/categories/编程语言/cpp/"}]},{"title":"other Language","date":"2019-03-20T14:13:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/cpp/其他语言融合/","text":"集合如何表示Math中“集合”的概念，有元素属于、有包含于、有交叉，等一系列和集合相关的概念 JNAjdk里面还提供了dll-lib-header来让c去调用javaoracle-1.5-示例有点旧示例-新 You must add &lt;JRE&gt;/bin/server to the PATH. This is something you must do unless you are allowed to copy the Java Virtual Machine dynamic library (JVM.dll) into the path of your executable. you must add the directories &lt;JDK-DIR&gt;/include and &lt;JDK-DIR&gt;/include/win32 to the include directories of your compiler. Note that the win32 directory Is platform dependent. 通过看java编译出的class文件会发现，method的签名和cpp调java很像，都是缩写，比如void是V。callvoidmethod和callvoidmethoda区别就是va_list 注意：这个和java调用c一样，32/64都必须一一对应。否则会报错unresolved external symbol _imp_jni_createjavavm@12 referenced 注意：和java调用c一样不允许函数签名有cpp的reference或者自定义个class，只能是严格的c类型。c调用java也一样，不允许传递reference给java的函数，或者像std::string这种不能用cpp类型","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"JNA","slug":"JNA","permalink":"http://yoursite.com/tags/JNA/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"cpp","slug":"编程语言/cpp","permalink":"http://yoursite.com/categories/编程语言/cpp/"}]},{"title":"Old-C","date":"2019-03-20T14:13:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/cpp/特殊的C/","text":"C函数的不定参数va意为variable-argument可变参数，C定义了如下的宏va_list, va_start,va_end,va_arg. 1void f(int i, ...)&#123;&#125; 可变参数函数详解 Unable to Count __VA_ARGS__ Arguments c与cpp有重叠的地方，但不重叠的地方很难互相用，比如reference和va。 va-list-va-start-reference cplusplus示例 msdn示例 示例 va_list使用 va-start问题 va_arg __VA_ARGS__问题1 __VA_ARGS__问题2 ##__VA_ARGS__问题3 C宏 用可变参数宏(variadic macros)传递可变参数表 C中的宏的使用(宏嵌套/宏展开/可变参数宏) 参数个数可变的宏 C/C++中的宏的使用技巧(宏嵌套/宏展开/可变参数宏) msdn官方文档variadic-macros 括号的用处 函数宏,连续调用两个 函数宏 C语言宏定义函数的使用(定义单行和多行） 编译器-宏__LINE__, __FILE__, __func__ built-in Type数组 字节数组 删除2维数组 定义char数组和初始化 数组内存模型 array sizeconst integer——–noconst expression—-yes(for example macro) float 和 double区别 大小估值#include&lt;cstd&gt;|bit|number||:-:|:-:||16|6e4||32|4e10||64|18e20| cstdiofile fopen fopen mode 文档 fwrite fread fread文档 check if a file exist using cpp windows自己实现了io.h里面提供_filelength来获取文件长度。linux可以有吗 printf, sprintf, fprintf int printf(const char* str, ...); function is used to print character stream of data on stdout console. int sprintf(char *str, const char *string,...); String print function instead of printing on console store it on char buffer which are specified in sprintf int fprintf(FILE *fptr, const char *str, ...); function is used to print the string content in file but not on stdout console. stdio.h safe-io sprintf_s与_snprintf与_snprintf_s print hex value dump a binary file as a C/C++ string literal char to hex integer to hex cctype isalnum表示alpha or number，需要用unsigned char，详见cppreference中的注意事项","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"template","slug":"template","permalink":"http://yoursite.com/tags/template/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"cpp","slug":"编程语言/cpp","permalink":"http://yoursite.com/categories/编程语言/cpp/"}]},{"title":"shadowsocks","date":"2018-12-22T03:15:58.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/network/shadowsocks/","text":"ubuntu官网参考流程 server1234567891011121314151617181920212223sudo apt install shadowsocks$ vim shadowsocks.json&#123; \"server\":\"my_server_ip\", #0.0.0.0可以适用任何IPv4 \"server_port\":8388, \"password\":\"mypassword\", \"port_password\":&#123; \"7788\":\"password0\", \"7789\":\"password1\", \"7790\":\"password2\" &#125;, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"timeout\":300, \"method\":\"rc-md5\", \"fast_open\": false, #CP加速（需要linux内核 3.7.1 以上） \"workers\": 100 #最大连接数量&#125;ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop 设置开机启动 12345678910111213141516sudo touch /etc/init.d/shadowsocks-start.shsudo vim /etc/init.d/shadowsocks-start.sh#! /bin/sh### BEGIN INIT INFO# Provides: shadowsocks# Required-Start: $remote_fs $syslog# Required-Stop: $remote_fs $syslog# Should-Start: $network $time# Should-stop: $network $time# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: shadowsocks.### END INIT INFO/usr/bin/ssserver -c /etc/shadowsocks.json -d start 设置启动等级sudo update-rc.d /etc/init.d/shadowsocks-start.sh defaults 90 client1234567891011121314151617sudo apt install shadowsocks$ vim shadowsocks.json&#123; \"server\":\"代理地址\", \"server_port\":代理端口, \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"password\":\"密码\", \"timeout\":600, \"method\":\"加密方式\"&#125;sslocal -c ~/shadowsocks.jsonsudo sslocal -c shawdowsocks.json -d startsudo sslocal -c shawdowsocks.json -d stop client全局代理 官网建议 代理软件推荐) proxychains 介绍 ubuntut的shadowsocks poliposudo apt-get install polipo 修改参数 修改参数 12345678910111213141516171819202122sudo vim /etc/polipo/configlogSyslog = truelogFile = /var/log/polipo/polipo.loglogFile = /var/log/polipologLevel=4proxyAddress = \"0.0.0.0\"proxyPort = 7070 #默认8123socksParentProxy = \"127.0.0.1:1080\"socksProxyType = socks5chunkHighMark = 50331648objectHighMark = 16384serverMaxSlots = 64serverSlots = 16serverSlots1 = 32 重启生效 1234567sudo /etc/init.d/polipo restartsudo service polipo stopsudo service polipo start#设置polipo为自启动systemctl enable polipo 设置环境变量export http_proxy=&quot;http://127.0.0.1:8123&quot; &amp;&amp; export http_proxy=&quot;http://127.0.0.1:8123&quot; 使用别名 123456alias hp=\"http_proxy=http://localhost:8123\"hp curl ip.gsgit config --global http.proxy=localhost:8123git clone https://github.com/torch/distro.git ~/torch --recursive 注： 1080 是 ss 提供的 socks5 协议代理 8123 是 polipo 提供的 http 协议代理 block 先检测端口开放 以及ip是否被qiang. 检查正常 尝试重启网络 ssh服务, 问题依旧 尝试修改ssh端口 问题依旧 尝试调查 sshd config文件里有没有禁止root登录等限制 没发现问题 调查防火墙是否开放端口 没发现问题 putty使用本地sock5代理连接 正常了…… 建议 建议2 VPS站 以被屏蔽 clients.hostwinds.com Just My Socks 未屏蔽 未屏蔽2 help","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"代理","slug":"代理","permalink":"http://yoursite.com/tags/代理/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"network","slug":"工具/network","permalink":"http://yoursite.com/categories/工具/network/"}]},{"title":"ubuntu-tool","date":"2018-12-22T03:15:58.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/Operator System/ubuntu-tool/","text":"brew软件安装工具brew fzf内容的模糊搜索 A command-line fuzzy finder github连接 在bash下用ctrl+T输入快捷键 炫酷演示 炫酷演示2 curlcurl文档 curl访问网站 wget下载文件很好用 youtube-dlgithub官网使用教程 注：ubuntu不要用apt来安装 12345678910111213# curl安装$ sudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dl$ sudo chmod a+rx /usr/local/bin/youtube-dl# wget安装$ sudo wget https://yt-dl.org/downloads/latest/youtube-dl -O /usr/local/bin/youtube-dl$ sudo chmod a+rx /usr/local/bin/youtube-dl# pip安装$ sudo -H pip install --upgrade youtube-dl# brew安装$ brew install youtube-dl 地址可不带引号12345678#不带任何参数，则默认下载画质、音质最好的文案。youtube-dl &quot;video_url&quot;#查看可选的视、音频格式youtube-dl -F &quot;video_url&quot;#从上述的信息中，按需挑选自己想要的视频、音频组合方案，填写对应的序号youtube-dl -f &apos;137+140&apos; &quot;video_url&quot;#如果视频带有字幕的话，则一并下载youtube-dl --write-sub --sub-format &quot;ass/srt/best&quot; --convert-subs &quot;srt&quot; &quot;video_url&quot; youtube的URL的特点 举例：https://www.youtube.com/watch?v=pA08fbvwcpc&amp;t=0s&amp;list=FLYBMrL9-SsgWXc1AWU7XamQ&amp;index=2 其中/watch?v=pA08fbvwcpc&amp;t=0s是真正的地址&amp;list=FLYBMrL9-SsgWXc1AWU7XamQ&amp;index=2是因为被个人保存到列表中。","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"Operator System","slug":"工具/Operator-System","permalink":"http://yoursite.com/categories/工具/Operator-System/"}]},{"title":"boost","date":"2018-12-22T03:15:58.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/boost/","text":"安装官方帮助文档github官方帮助文档编译要求 clang123$ ./bootstrap --with-toolset=clang$ ./b2 clean$ ./b2 toolset=clang cxxflags=&quot;-stdlib=libc++&quot; linkflags=&quot;-stdlib=libc++&quot; 12brew install boost --c++11brew info boost 1apt install libboost-dev 综述 官方文档 boost::log结构 log 很棒的10个例子虽然有些过时 架构研究 主页 学习使用 example example2 example3 example4 backend How to redirect ostream to Boost Log library - Stack Overflow Sink backends example How to redirect Boost.Log to file file number Boost.Log - how to configure a text sink backend to append to … simulaneous output immediately boost log file stdout console file log add console file log add2 Setting up sinks sink backends 概念 severity filter severity expr::format_date_time expressions.keyword expressions.attr_keywords expressions.formatters.named_scope name scope formatter trivial_filtering filter name scope advanced_filtering source(tutorial) source(detail) attributes(tutorial) attributes(detail) severity / local attributes attributes.named_scope filename attribute trivial(tutorial) utilities.setup utilities.setup.filter_formatter utilities.setup(add_common_attributes) 版本变化 宽字符支持 asio其他 http_parser proxygen是facebook出品，用到了上面的解析库。proxygen/lib/http/codec/HTTP1xCodec.cpp是对请求和响应报文的解析，可以看下他们如何实现的。其实本质就是对RFC协议内容的具体规定一点点实现。 切去过长日志 error.hpp asio综述 综述 c03, c11, c17三种例子 boost的asio还自带支持ssl，可以用来实现ssh/sftp 异步模型。The Proactor Design Pattern: Concurrency Without Threads, 线程模型 哲学Anatomy 用socket-stream来发http请求。例子 buffer 实现proxy功能 asio 阻塞读是否优先 asio https server asio guide buffer buffer大小多少合适 basic_streambuf streambuf作为缓冲区 read/write_some vs receive/send boost::asio::buffer: Getting the buffer size and preventing buffer … buffer_size Optimal buffer size with boost::asio in Windows Working with boost::asio::streambuf 发送接收缓存asio::buffer及asio::streambuf Use streambuf as buffer for boost asio read and write boost::asio::buffer: Getting the buffer size and preventing buffer cyclic buffer buffer read async async_read example infinite loop EOF asio::read EOF error list shutdown asio shutdown vs close asio ssl shutdown asio shutdown 与log配合一旦和log库一起使用，msvc就必须要用(PreprocessorDefinitions)指定版本(WINVER=0x0A00;_WIN32_WINNT=0x0A00;)，否则就会报log的编译错误LNK2038: mismatch detected for ‘boost_log_abi’: value ‘v2s_mt_nt5’ doesn’t match value ‘v2s_mt_nt6’Ask Question。 Modifying WINVER and _WIN32_WINNT MSC_VER _WIN32_WINNT’ / ‘WINVER’ : macro redefinition这个问题主要是和targetver.h与sdkddkver.h有关。 asio与windows.h冲突解决会与windows自带的socket库冲突，往往会报很多socket函数冲突什么的，只需要保证boost在windows.h之前就可以 process用来执行一些cmd，感觉用py或ps1或sh更好，但也能做。 好像对编译器版本有要求，即至少C11以上，我记得是。 文档 异步执行 boost::filesystem已经被c17招安了 get file extension from string copy_file delete file mkdir file extension 命名检查 文件名检查 boost::property_tree 可以解析xml、ini等文件 可以解析ini文件 xml文件 其他文本解析 iterate boost property_tree access data in property tree boost ini file parse Boost ini_parser - Singleton DLL issue boost/property_tree c++ ptree用法- 如何使用Boost解析ini文件 INI file - Wikipedia 注：xml可以用pugixml或者TinyXml, RapidXml。且xml很需要xpath的语法，用起来才爽。pugixml示例 format 示例 example doc 问题 zero pad to string hex output doc2 thread, future future &amp; promise thread.join() boost::thread线程创建方式 简介 thread pool create thread pool think-async 线程池 thread_pool官方文档 boost::threadpool thread_group和io_service quora讨论 Creating a Work Queue (Thread Pool) Boost.Threads boost::threadpool archivebase64 encode decode or encode decode encode/decode encode 网上的教程往往只完成了”68”的转化，但实际过程如下。 encode 6-&gt;8的转化 补足”=” decode 移除补齐的”=” 8-&gt;6的转化 pythonBoost.Python 简明教程 functionbind 经常报错result_type is not a member of global namespace 经常报错F must be a class or namespace when followed ‘::’ 帮助文档 doc boost::arrary这个也被c11收编 Copying boost::array&lt;char&gt; to std::string","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"boost","slug":"boost","permalink":"http://yoursite.com/tags/boost/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"nmake-msbuild","date":"2018-12-16T12:12:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/IDE/nmake-msbuild/","text":"nmake示例 1 2 错误 环境 CL LINK 编译器架构(x86 or x64) command prompt 32/64 位系统编译在32位系统上运行 =&gt; x8632 系统上编译64位系统上运行 =&gt; x86_amd6464 系统上编译在64位系统上运行 =&gt; amd64解释注：以下引自MSDNThe following list describes the various versions of cl.exe (the Visual C++ compiler): x86 on x86Allows you to create output files for x86 machines. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system.Itanium on x86 (Itanium cross-compiler)Allows you to create output files for Itanium. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system. x64 on x86 (x64 cross-compiler)Allows you to create output files for x64. This version of cl.exe runs as a 32-bit process, native on an x86 machine and under WOW64 on a 64-bit Widows operating system. Itanium on ItaniumAllows you to create output files for Itanium. This version of cl.exe runs as a native process on an Itanium machine. x64 on x64Allows you to create output files for x64. This version of cl.exe runs as a native process on an x64 machine. Vcvarsall.bat argument Compiler Host (either natively or using emulation) Target architecture“x86” (default) 32-bit Native x86, x64, Itanium x86“x86_amd64” x64 Cross X86, x64, Itanium x64“x86_IPF” Itanium Cross X86, x64, Itanium Itanium“amd64” x64 Native x64 x64“IPF” or “itanium” Itanium Native Itanium Itanium cmd中使用nmake msvc toolset command line 执行下列命令就等价于启动Vs2015 x64 native tools command prompt 12set PATH=C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64;%PATH%&quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat&quot; x64 这个作用不详，不清楚&quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\vcvars32.bat&quot; 命令行 nmake怎么添加宏定义 nmake设置环境变量 cl编译器选项总结 winDBG类似gdb之于gcc，gdb与windDBG对比 windbg windbg_sos windbg_sosex why winDBG is better vsDebugger","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"nmake","slug":"nmake","permalink":"http://yoursite.com/tags/nmake/"},{"name":"msbuild","slug":"msbuild","permalink":"http://yoursite.com/tags/msbuild/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"emscripten","date":"2018-12-16T12:12:54.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/工具/IDE/emscripten/","text":"参考文档Emscripten is an LLVM-to-JavaScript compiler. Building-Projects FAQ Interacting-with-code Tutorial compiling-and-running webassembly 安装123emsdk install latestemsdk_env.batemcc -v 也可以直接下载已经编译好的binary文件exe。他会帮你在path中添加很多。 问题pthread我用boost的asio，配合emmake（因为他内部是clang，无论在win/linux都是要用pthread），始终无法转换成js。 下列内容也只是参考，实际问题并没解决12 用emcc配合-s USE_PTHREADS=1，没什么用，都只是单文件。 官网示例–编译大工程都是2010年的老黄历 FreeType字形图glyph image产生工具openjpeg图像内存解压缩(解码)zlib压缩bullet游戏世界占有率为第三的物理引擎poppler用来渲染 PDF 文档的自由程序库 github上相关工程github该topic下的搜索结果 perspective","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"emcc","slug":"emcc","permalink":"http://yoursite.com/tags/emcc/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"LLVM","date":"2018-12-16T12:12:54.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/工具/IDE/llvm/","text":"安装可以自己编译。可以直接下载编译完成的版本。 ubuntu注意匹配当前系统版本代号apt安装-官方教程apt安装教程 我的ubuntu软件源似乎没法找到很多llvm依赖的软件。还需按该网址添加，才能完成下载。 123456789101112131415Some packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: clang-7 : Depends: libllvm7 (&gt;= 1:7~svn298832-1~) but it is not going to be installed Depends: libstdc++6 (&gt;= 4.9) but 4.8.4-2ubuntu1~14.04.4 is to be installed Depends: libstdc++-4.9-dev but it is not installable Depends: libgcc-4.9-dev but it is not installable Depends: libobjc-4.9-dev but it is not installable Depends: libclang-common-7-dev (= 1:7.0.1~svn348686-1~exp1~20181213084532.54) but it is not going to be installed Depends: libclang1-7 (= 1:7.0.1~svn348686-1~exp1~20181213084532.54) but it is not going to be installedE: Unable to correct problems, you have held broken packages. windows官方编译版本，好像缺少lld等工具。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"llvm","slug":"llvm","permalink":"http://yoursite.com/tags/llvm/"},{"name":"clang","slug":"clang","permalink":"http://yoursite.com/tags/clang/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"WebAssembly","date":"2018-12-14T14:12:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/wasm/","text":"简介是什么 示例介绍 怎么用1怎么用2怎么用3怎么用 怎么用4 工具官方github LLVM编译器 等价于： 前端+语法解释器+后端。LLVM中前端是clang 历史版本 windows编译结果 github地址 windows编译 QT官方1官方2qt版wasm 工具链binaryen wabt emsdkemsdk(emcc)怎么用emscripten官网emscripten的github 示例 C++C/C++面向WebAssembly编程 怎么用 优秀应用asm-domgccxasm-domasm-dom-boilerplateasm-dom-OO-counters 其他1 2 3 4","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"wasm","slug":"wasm","permalink":"http://yoursite.com/tags/wasm/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"WebAssembly示例","date":"2018-12-14T14:12:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/wasm example/","text":"失败例子123456789101112131415echo %PATH%set PATH=E:\\ProgramFiles\\LLVM\\7.00x64\\LLVM\\bin;%PATH%clang++ --target=wasm32 magic.cpp -emit-llvm -o magic.bc -cllc -march=wasm32 -filetype=asm magic.bc -o magic.sset PATH=d:\\CodeProject\\binaryen-master\\build\\bin\\;%PATH%asm2wasm --helpasm2wasm helloWorld.asm.js &gt; helloWorld.wasmemcc magic.cpp -s WASM=1 -o magic.html 示例一参考 将C的func编译成js，可以被js调用 代码12345678910111213extern &quot;C&quot; &#123;int add(int x, int y) &#123; int a=333; return x + y+ a;&#125;int magic()&#123; return 1;&#125;&#125; 指令emcc example.c -o example.js -s &quot;EXPORTED_FUNCTIONS=[&#39;_magic&#39;,&#39;_hello&#39;]&quot; js中调用123var em_module = require(&apos;./example.js&apos;);em_module.ccall(&quot;magic&quot;);console.log(em_module._add(1,2)); 注： 如果不加extern “c”{}则转出的wasm文件对应的wast文件只有module这个词【未测试，实际不详】 这里EXPORTED_FUNCTIONS指的是导出的函数，需要和源文件里的函数名是相对应的。【因为C/C++编译器存在name mangle，所以会是这个带下划线的名字】 -O3是编译优化等级，只有这个等级生成的wasm文件才会很小（几十字节），不加该优化选项，生成的wasm将会有几十KB。 生成的时候会临时产生*.asm.js，等生成完后，会自动删掉。 执行完将会生成 extern.js和extern.wasm两个文件。 12emcc test.cpp -o test.js -s &quot;EXPORTED_FUNCTIONS=[&apos;_add&apos;,&apos;_min&apos;]&quot; -O3emcc magic.cpp -o magic.js -s &quot;EXPORTED_FUNCTIONS=[&apos;_magic&apos;,&apos;_hello&apos;]&quot; 本质上该emcc执行的是python脚本，所以命令行中的参数是和python的类型相关，可能会报类型错误。node run.js 示例二编译工程，而不是单个文件 普通用cmake直接编译12cmake -DCMAKE_BUILD_TYPE=Release -G &quot;NMake Makefiles&quot; ..make --build . 执行完build后，唯一区别是在[CMakeFiles].[XXXX.dir].[depend.make]文件变化，并新增了[CMakeFiles].[XXXX.dir].[depend.internal和CXX.includecache]两个文件，其余没有任何变化 用em的工具来特殊编译 123emconfigure cmake ..emmake cmake --build . #这个如果是带main的cpp就会生成一个可执行main内容的js，node xxx.js 执行123emconfigure cmake -DCMAKE_BUILD_TYPE=Release -G &quot;NMake Makefiles&quot; ..emake cmake --build .emmake nmake 结果报错如下：12345678910111213141516171819202122232425.lib advapi32.lib /MANIFEST /MANIFESTFILE:boostUse.exe.manifest&quot; failed (exit code 1104) with the following output:LINK : fatal error LNK1104: 无法打开文件“libboost_date_time-vc140-mt-x32-1_69.lib”NMAKE : fatal error U1077: “E:\\ProgramFiles\\CMake\\bin\\cmake.exe”: 返回代码“0xffffffff”Stop.NMAKE : fatal error U1077: “&quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\amd64\\nmake.exe&quot;”: 返回代 码“0x2”Stop.NMAKE : fatal error U1077: “&quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\amd64\\nmake.exe&quot;”: 返回代 码“0x2”Stop.ERROR:root:compiler frontend failed to generate LLVM bitcode, haltingNMAKE : fatal error U1077: “E:\\ProgramFiles\\Emscripten\\emscripten\\1.35.0\\em++.bat”: 返回代码“0x1”Stop.NMAKE : fatal error U1077: “&quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\amd64\\nmake.exe&quot;”: 返回代 码“0x2”Stop.NMAKE : fatal error U1077: “&quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\amd64\\nmake.exe&quot;”: 返回代 码“0x2”fatal error: too many errors emitted, stopping now [-ferror-limit=]13 warnings and 20 errors generated.ERROR:root:compiler frontend failed to generate LLVM bitcode, haltingNMAKE : fatal error U1077: “E:\\ProgramFiles\\Emscripten\\emscripten\\1.35.0\\em++.bat”: 返回代码“0x1”Stop.NMAKE : fatal error U1077: “&quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\amd64\\nmake.exe&quot;”: 返回代 码“0x2”Stop.NMAKE : fatal error U1077: “&quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\amd64\\nmake.exe&quot;”: 返回代 码“0x2” 原因是如果PATH变量中存在MinGW他会把它作为linker，然后就会有很多奇怪的和boost的header相关的报错。 其他，暂未归类cmake –helpset PATH=E:\\ProgramFiles\\CMake\\bin;%PATH% cmake .. -G “Visual Studio 14 2015” 使用的是x86（32bit）msbuild xxxx.sln cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=install -G “Visual Studio 14 2015”cmake –build . –config Release –target install他是默认Debug模式，安装在Debug目录下。这个target好像是制定了vcxproj的名字。 cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=install -DBUILD_TESTS=OFF -G “Visual Studio 14 2015” 错误示范emconfigure cmake –config=Release ..emmake cmake . –config=Release –target ..emmake cmake –build . –config=Release –target=..emmake cmake –config=Release –target=install –build .错误示范emconfigure cmake ..emmake cmake –build . –config=Releaseemmake cmake –config=Release –build . 正确示范emconfigure cmake ..emmake cmake –build . 错误示范emcc libtestCmake.a -o project.js 正确示范emcc libtestCmake.a -o project.js -s “EXPORTED_FUNCTIONS=[‘_magic’,’_hello’]” 正确示范cmake –config=Release –build .","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"emcc","slug":"emcc","permalink":"http://yoursite.com/tags/emcc/"},{"name":"wasm","slug":"wasm","permalink":"http://yoursite.com/tags/wasm/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"gitbook","date":"2018-10-19T13:58:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/gitbook/","text":"websitelegacy www 其他介绍123 windows 安装node -vnpm install gitbook-cli -g 使用简单1234567891011gitbook initgitbook buildgitbook servegitbook helpgitbook -Vgitbook lsgitbook ls-remotegitbook update pdfgitbook pdf ./ ./mybook.pdf 需要安装下面两个软件npm install ebook-convert calibre","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"gitbook","slug":"gitbook","permalink":"http://yoursite.com/tags/gitbook/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Netty","date":"2018-10-02T23:00:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/netty/","text":"## 拦截器———职责链模式 ServletFilter ChannelPipelineChannelHandlerChannelHandlerContext ChannelInboundHandler之间的传递，通过调用 读事件，比如ctx.fireChannelRead(msg) 实现；【super.channelRead(ctx, msg);其实也是执行的ctx.fireChannelRead(msg)】 调用ctx.write(msg) 将传递到ChannelOutboundHandler。 ctx.write()方法执行后，需要调用flush()方法才能令它立即执行。 ChannelOutboundHandler 在注册的时候需要放在最后一个ChannelInboundHandler之前，否则将无法传递到ChannelOutboundHandler。 Handler的消费处理放在最后一个处理。【消费必然是ChannelInboundHandler的实现类】 Handler可以同时实现InBound、OutBound这样In、Out时都会调用 【如果调用的是ctx.channel().write()是从尾开始执行，不会有博主说的问题，如果是直接用ctx.write()时则会有博主说的问题】","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"}]},{"title":"MatLab","date":"2018-10-01T14:39:54.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/工具/IDE/Matlab/","text":"matlabmatlab和C++有以下内容： mcl-com-class, mcl-cpp-class, mcl-mcr(lib), mcl-mcr-rt(lib), matrix-lib-mx, matrix-lib-mat,其中还有很多。实在是不好用。","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"MatLab","slug":"MatLab","permalink":"http://yoursite.com/tags/MatLab/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"pycharm","date":"2018-10-01T14:39:54.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/工具/IDE/PyCharm/","text":"设置 设定好interpret。 安装插件Preferences --&gt;&gt; Plugins。IDE安装插件Settings/Preferences dialog and then go to Plugins。比如: vim git的.ignore。 设定文件模板File --&gt;&gt; Setting --&gt;&gt; Editor --&gt;&gt; File and Code Templates --&gt;&gt; Python Script为 1234567891011121314151617181920#!/usr/bin/env python# encoding: utf-8\"\"\"@author: $&#123;USER&#125;@software: $&#123;PRODUCT_NAME&#125;@file: $&#123;NAME&#125;.py@time: $&#123;DATE&#125; $&#123;TIME&#125;\"\"\"def func(): passclass Main(object): def __init__(self): passif __name__ == '__main__': pass 设置行号File --&gt;&gt; Settings --&gt;&gt; Editor --&gt;&gt; Appearance ，勾选 Show Line Numbers。 然后呢？ 1. 安装插件【ananconda基本上都齐全了】 2. 创建virtual environment？ 3. 如何debug呢？？ 4. 如何组织文件呢？ 插件, 快捷键与java的Intelij用法习惯基本差不多 vim的启动和禁止(ctrl+alt+v)，在菜单栏Tools-&gt;Vim Emulator ctrl+shift+a然后输入plugin就可以快速进入plugin安装 IDE在当前行alt+enter，会有智能提示，包括auto import​ project IDE运行程序，文件路径默认搜索source root。设定“sources root”，这样默认开始，就知道从哪里开始import。通过右键点击文件夹最下面Mark directory as ----------&gt; sources root 设定“env”，最上面的菜单栏File----&gt;Settings-----&gt;Project:XXX-----&gt;Project Interpreter-----&gt;Create Virtual Env重启就可以了。然后用pip install -r requirement.txt完成环境搭建。每次写完了app，记得更新pip freeze &gt; requirement.txt。可以用ide自带的gui来添加库，也可以用IDE下面的命令行Terminal来。","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"pycharm","slug":"pycharm","permalink":"http://yoursite.com/tags/pycharm/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"Visual Studio","date":"2018-10-01T14:39:54.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/工具/IDE/Visual Studio/","text":"版本 VS VC MSVC++ _MSC_VER C6.0 600 C/C++7.0 700 1.0 800 2.0 900 4.0 1000 5.0 1100 Visual Studio 6 vc6 6.0 1200 Visual Studio 2003 vc7 7.0(7.1) 1300(1310) Visual Studio 2005 vc8 8.0 1400) Visual Studio 2008 vc9 9.0 1500 Visual Studio 2010 vc100 10.0 1600 Visual Studio 2012 vc110 11.0 1700 Visual Studio 2013 vc120 12.0 1800 Visual Studio 2015 vc140 14.0 1900 VS常用功能 Title1 Title2 Python Environment Ctrl+K, Ctrl+` Solution Exploer Ctrl+Alt+L 查找Find Ctrl+F(其中Match Case:Alt+C;Match Whole Word:Alt+W) 替换Replace Ctrl+H(其中Replace Next:Alt+R;Replace All:Alt+A) 管理我们下载的插件 Tools-&gt;Extension and Update evaluate expression while debug debug running process include path global include path Visual Assist我们就可以实现圈出一段代码，然后按”/”就可将其装换成注释 VS中的编译选项RunTime-library【msvcrt==MsVC-RT】———-又叫做C Runtime library，可以看书《Win32 多线程程序设计（侯捷译）》libcmt.lib是windows环境下vc提供的静态运行时库（多线程）；msvcrt.lib是windows环境下vc提供的动态运行时库。 动态链接：MD、MDd——-libcmt.lib, libcmtd.lib静态链接：MT、MTd——-msvcrt.lib, msvcrtd.liblib后面带d表示是DEBUG版本。 这两个库都位于 MFCmulti-thread-dll(MTd) 构建选项添加目录到工程1 添加构建时环境变量添加dll的path添加dll的path 比如：Search MSDN for “How to: Set Environment Variables for Projects”. (It’s Project&gt;Properties&gt;Configuration Properties&gt;Debugging “Environment” and “Merge Environment” properties for those who are in a rush.) The syntax is NAME=VALUE and macros can be used (for example, $(OutDir)). 编译报错LNK2026 safeseh这个是因为C没有exception处理，所以Windows给提供的SEH,而且还可以用来加密程序，防破解。SAFESEH is a security feature and as all compiler/linker security features it is optional. 解决方案 2注：链接错误经常是unresolved external symbol __imp__****后面才是真的函数名，前面的不算。__imp__表示构建时使用dynamic library mangling，而非static library。 3警告C4005 _useHeader和__on_failure宏重定义，这是因为VS2012和Win7默认的inlcude/lib有冲突，参考 4Error C1083: Cannot open source file” Shouldn’t Be Looking For The File At All参考 5编程中经常能遇到LNK2005错误——重复定义错误。造成LNK2005错误主要有以下几种情况：1．重复定义全局变量。可能存在两种情况：A、对于一些初学编程的程序员，有时候会以为需要使用全局变量的地方就可以使用定义申明一下。其实这是错误的，全局变量是针对整个工程的。正确的应该是在一个CPP文件中定义如下：int g_Test;那么在使用的CPP文件中就应该使用：extern int g_Test即可，如果还是使用int g_Test，那么就会产生LNK2005错误，一般错误错误信息类似：AAA.obj error LNK2005 int book c？ book@@3HA already defined in BBB.obj。切记的就是不能给变量赋值否则还是会有LNK2005错误。这里需要的是“声明”，不是“定义”！根据C++标准的规定，一个变量是声明，必须同时满足两个条件，否则就是定义：(1)声明必须使用extern关键字；(2)不能给变量赋初值所以，下面的是声明:extern int a;下面的是定义int a; int a = 0; extern int a =0; B、对于那么编程不是那么严谨的程序员，总是在需要使用变量的文件中随意定义一个全局变量，并且对于变量名也不予考虑，这也往往容易造成变量名重复，而造成LNK2005错误。 2．头文件的包含重复。往往需要包含的头文件中含有变量、函数、类的定义，在其它使用的地方又不得不多次包含之，如果头文件中没有相关的宏等防止重复链接的措施，那么就会产生LNK2005错误。解决办法是在需要包含的头文件中做类似的处理：#ifndef MY_H_FILE //如果没有定义这个宏#define MY_H_FILE //定义这个宏……. //头文件主体内容…….#endif上面是使用宏来做的，也可以使用预编译来做，在头文件中加入：#pragma once//头文件主体 3．使用第三方的库造成的。这种情况主要是C运行期函数库和MFC的库冲突造成的。具体的办法就是将那个提示出错的库放到另外一个库的前面。另外选择不同的C函数库，可能会引起这个错误。微软和C有两种C运行期函数库，一种是普通的函数库：LIBC.LIB，不支持多线程。另外一种是支持多线程的：msvcrt.lib。如果一个工程里，这两种函数库混合使用，可能会引起这个错误，一般情况下它需要MFC的库先于C运行期函数库被链接，因此建议使用支持多线程的msvcrt.lib。 所以在使用第三方的库之前首先要知道它链接的是什么库，否则就可能造成LNK2005错误。如果不得不使用第三方的库，可以尝试按下面所说的方法修改，但不能保证一定能解决问题，前两种方法是微软提供的：A、选择VC菜单Project-&gt;Settings-&gt;Link-&gt;Catagory选择Input，再在Ignore libraries 的Edit栏中填入你需要忽略的库，如：Nafxcwd.lib;Libcmtd.lib。然后在Object/library Modules的Edit栏中填入正确的库的顺序，这里需要你能确定什么是正确的顺序。 B、选择VC菜单Project-&gt;Settings-&gt;Link页，然后在Project Options的Edit栏中输入/verbose:lib，这样就可以在编译链接程序过程中在输出窗口看到链接的顺序了。 C、选择VC菜单Project-&gt;Settings-&gt;C/C++页，Catagory选择Code Generation后再在User Runtime libraray中选择MultiThread DLL等其他库，逐一尝试。 vscode设置","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://yoursite.com/tags/Visual-Studio/"},{"name":"VScode","slug":"VScode","permalink":"http://yoursite.com/tags/VScode/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"QtCreator","date":"2018-10-01T14:39:54.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/工具/IDE/QtCreator/","text":"QTDEBUG数组变量 add evaluation equal 12&#123;TYPE[size]&#125;*Name*Name&amp;size size别太大了，不然溢出了。 debug时，可以用continue让其执行下个间断点，该按钮同样适用于循环语句，很好用。 qt中的project添加“当前文件路径”而不是“绝对路径” linux的QT添加std库。 通过命令gcc -v找到std位置，添加到pro中。","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"QT","slug":"QT","permalink":"http://yoursite.com/tags/QT/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"mpush","date":"2018-10-01T00:41:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/mpush/","text":"简述官网 个人很喜欢作者的代码风格（尤其是命名、OOP选择），想学习下。 作者没有用Spring框架。 只是简单用guava、apache-common、slf4j，再加上自己的封装，完成了整个系统构建。 用zookeeper作为服务的注册、发现中心。且自己实现了封装。—-可以借此看看eureka是不是也有点像这个。 SPI–底层组件更换作者思考 123一种应用介绍：MIDI接口 SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制。SPI是一种动态替换发现的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。 数据库DriverManager、Spring、ConfigurableBeanFactory等都用到了SPI机制， JDBC在java中定义了接口java.sql.Driver，并没有具体的实现，具体的实现都是由不同厂商来提供的。 作者定义了很多基础组件的接口xxxxFactory，我们第三方开发者就是厂商，可以提供其他实现 SpiLoader 他并非是类似Spring的IOC容器。 他想做的是系统本身有个default实现，后续可以轻松替换原有实现。比如更换MQ、更换Cache、更换service registry等等 configCC 实现了Spring的Application.properties的功能。 基于com.typesafe.config这个dependecy实现。 任务链场景：环境初始化，需要很多个步骤，步骤之间有依赖关系，如何去刻画这个完整过程。 mpush-boot的代码都回答了。 ###先后顺序 步骤间的执行顺序的确定 BootChain，用于将整个任务链串起来，定义下列内容 chain() setNext() start() stop() 像点鞭炮一样， 组装鞭炮—setNext() 环境构建—start()—-比如：登陆用户、创建连接等 环境解构—stop()—–比如：用户退出、关闭连接等 抽象类BootJob【他的实现类都叫???Boot】 成员变量BootJob startNext()——由内部的start()调用 stopNext()——-有内部stop()调用setNext()start()stop() 依赖作者对与每个BootJob的实现类，用构造函数引入依赖，如果用Spring，可以定义一个non-param的ctor，然后用setter实现依赖注入，也不错 “步骤”间的共同完成一个环境构建（他是为了完成一个mpushServer的构建，mpush就是所有步骤的依赖）。 性能监控模块mpush-tool负责 Profilter 老树盘根都在包mpush-api中 接口Service接口Factory","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"mpush","slug":"mpush","permalink":"http://yoursite.com/tags/mpush/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://yoursite.com/tags/zookeeper/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"}]},{"title":"spring security","date":"2018-09-26T14:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring security/","text":"网站1 问题关闭MVC的security@PreAuthorize 解决办法","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring security","slug":"spring-security","permalink":"http://yoursite.com/tags/spring-security/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"spring event","date":"2018-09-26T14:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring event/","text":"网站1 2 3 4 5","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring event","slug":"spring-event","permalink":"http://yoursite.com/tags/spring-event/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"spring amqp","date":"2018-09-26T14:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring amqp/","text":"网站https://www.cnblogs.com/wade-luffy/p/6004219.html https://my.oschina.net/jwl210/blog/810646 https://spring.io/projects/spring-amqp https://docs.spring.io/spring-amqp/reference/htmlsingle/ https://spring.io/guides/gs/messaging-rabbitmq/","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring amqp","slug":"spring-amqp","permalink":"http://yoursite.com/tags/spring-amqp/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"grammar","date":"2018-09-26T14:13:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/cpp/grammar/","text":"operator overloadoperator*()和operator-&gt;()重载关于指针的操作符operator*()和operator-&gt;()具体? ++前缀和后缀，operator++ prefix or postfix关于前缀self&amp; operator++()和后缀self operator++(int)约定俗成？？内容参考《C++Primer》P567-569 stackoverflow 12345678910111213141516171819class Number&#123; public: Number&amp; operator++ () // prefix ++ &#123; // Do work on this. (increment your object here) return *this; &#125; // You want to make the ++ operator work like the standard operators // The simple way to do this is to implement postfix in terms of prefix. // Number operator++ (int) // postfix ++ &#123; Number result(*this); // make a copy for result ++(*this); // Now use the prefix version to do the work return result; // return the copy (the old) value. &#125;&#125;; booloperator bool() const含义 1 operator &lt;做大小关系判断时，不要使用operator &gt;因为默认class只定义operator &lt; C++ programmers prefer using != to using &lt;这是因为泛型编程，相不相等是一个我们根本无需定义operator！！！而小于，这是一个很容易让我们要去考虑是否该template是否支持该operator 其他汇总 位移运算,若是使用int a = (1&gt;&gt;8);不行；使用int a=1; a=&gt;&gt;8;可行 疑惑，一个字符串为&quot;a.&quot;使用tmp=a[i];a[i++]=a[j];a[j--]=tmp;无法达到目的，这种后缀形式，哪里出问题了？ 涉及除法运算,一定要检验除数是否为0!!!! 条件操作符conditions?expression1:expression2这两个expression必须得同类别,比如说,你在这个最左边接了个cout&lt;&lt;,你这俩要有一个是”….”另一个也必须是string!!!!! Unknown override specifier, missing type specifier How to use enums in C++ use goto? 循环while(true)和for(;;)没区别12 system time3种方式 verify string format with given patternregular expression Forward decalaration预声明vim对该问题的错误提示为field has incomplete type ‘XXX’谷歌给的问题解释if you use a forward declaration for the type “XXX”,that is fine, but it also means that you can only declare a pointer or reference to that type.Otherwise the compieler has no idea how to allocate the parent object as it doesn’t know the size of the forward declared type ( or if it actually has parameterless constructor, etc.)总结一句话就是预声明类型后，你只能利用该类型创建指针或引用，不能拿来创建object，因为编译器不知道要给他多大的内存，除非你include该类型的h文件。 注：当我把该type’XXX’放在std类型中的vector或者map中却不会报错！！！！，当然，std的智能指针shared_ptr和unique_ptr肯定是没问题的，因为实质是个指针！！！而上面的vector他们却是要申请实体内存的！！！这是为什么？？？？ 这么做的好处是什么，它与include该类型的h文件相比优劣性如何？？？ 案例: 在EventLoop.h中class Poller;`std::unique_ptr p;编译时报错，显示std::unique_ptr&lt;&gt;`error: invalid application of ‘sizeof’ to incomplete type ‘Poller’问题出在我将EventLoop的析构函数也定义在该H文件中，而析构函数会自动调用成员数据的析构函数，但是Poller仅仅是前向声明。所以切记要在.cc中定义析构。 Basic–Function 函数declared时,我们可以省略parameters中的具体名字,反正没什么意义,只要指明变量类型即可.但是函数define时,必须要有parameters具体名字,不然函数体怎么使用他们…. 当你declared一个函数parament使用的是initializer_list&lt;&gt;时,你调用该函数,其中argument必须要用{}包含进去,不然没法编译!!! control reach end of non-void functionThe compiler cannot tell from that code if the function will ever reach the end and still return something. To make that clear, replace the last else if(...) with just else.我的实际出错的问题是，当递归函数是需要返回值时，我的每次调用递归，都应该使用return，否则毫无意义！！ exception c++中try catch的用法 C++异常处理入门（try和catch） error C2712: 没法在要求对象展开的函数中使用 _try VS2010:“error C2712: 无法在要求对象展开的函数中使用__try","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"grammar","slug":"grammar","permalink":"http://yoursite.com/tags/grammar/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"cpp","slug":"编程语言/cpp","permalink":"http://yoursite.com/categories/编程语言/cpp/"}]},{"title":"spring scheduler","date":"2018-09-18T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring scheduler/","text":"介绍官方 官方 1","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring scheduler","slug":"spring-scheduler","permalink":"http://yoursite.com/tags/spring-scheduler/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"spring integration","date":"2018-09-18T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring integration/","text":"## 1","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring integration","slug":"spring-integration","permalink":"http://yoursite.com/tags/spring-integration/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"tensorflow","date":"2018-09-18T14:57:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/python/tensorflow/","text":"## 安装指南1 2 3 4 5 6 7 8 9 10 11 12 13 ##问题 Tensorflow - ValueError: Parent directory of trained_variables.ckpt doesn’t exist, can’t save modelName = “YourModelName” saver.save(session, ‘./‘+modelName) ImportError: No module named ‘_pywrap_tensorflow’ Failed to load the native TensorFlow runtime. solution Failed to Load the native TensorFlow Runtime solution","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"python","slug":"编程语言/python","permalink":"http://yoursite.com/categories/编程语言/python/"}]},{"title":"jackson","date":"2018-09-17T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/jackson/","text":"How to convert Java object to / from JSON (Jackson)12345678910111213141516ObjectMapper mapper = new ObjectMapper();User user = createDummyUser();//Convert object to JSON string and save into file directly mapper.writeValue(new File(&quot;D:\\\\user.json&quot;), user); //Convert object to JSON stringString jsonInString = mapper.writeValueAsString(user); //Convert object to JSON string and pretty printjsonInString = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(user);// Convert JSON string from file to ObjectUser user = mapper.readValue(new File(&quot;G:\\\\user.json&quot;), User.class);// Convert JSON string to ObjectUser user1 = mapper.readValue(jsonInString, User.class);","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"jackson","slug":"jackson","permalink":"http://yoursite.com/tags/jackson/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"}]},{"title":"Spring-cloud-stream/bus","date":"2018-09-17T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring-cloud/spring cloud stream bus/","text":"bus和stream关系Spring Cloud Bus links nodes of a distributed system with a lightweight message broker. This can then be used to broadcast state changes (e.g. configuration changes) or other management instructions. A key idea is that the Bus is like a distributed Actuator for a Spring Boot application that is scaled out, but it can also be used as a communication channel between apps. Starters are provided for an AMQP broker as the transport or for Kafka, but the same basic feature set (and some more depending on the transport) is on the roadmap for other transports. Spring Cloud Bus is built on top of Spring Cloud Stream.It’s a Spring Cloud Stream application. bus广播书上说的config-sever也需要配置bus，也是错误的。我在实际过程中，只有config-client用bus，也能达到更新推送等功能。 Stream1 kafka官方文档","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring-cloud-stream","slug":"spring-cloud-stream","permalink":"http://yoursite.com/tags/spring-cloud-stream/"},{"name":"spring-cloud-bus","slug":"spring-cloud-bus","permalink":"http://yoursite.com/tags/spring-cloud-bus/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring-cloud","slug":"开源库/java/spring-cloud","permalink":"http://yoursite.com/categories/开源库/java/spring-cloud/"}]},{"title":"spring-cloud-feign","date":"2018-09-17T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring-cloud/spring cloud feign/","text":"版本FinchleyFinchley 这个版本 已经无需添加@EnableDiscoveryClient注解了。（那么如果我引入了相关的 jar 包又想禁用服务注册与发现怎么办？设置eureka.client.enabled=false） Finchley版本spring-cloud-starter-openfeign且必须有spring-cloud-starter-ribbon。否则报错No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon? 问题“Circular view path”问题一，是不是get不能内部跳转到post。——————错问题二，是不是一个url不能有get、post、delete多个方法。–错“Circular view path” 不是上述原因导致。 You’ve annotated the controller method as producing JSON, but it returns void. You probably want to annotate the method with @ResponseBody and change its return type to allow you to return an object representation of the JSON that you want to include in the response。You can use @RestController in your Spring Boot project instead of @Controller annotation. In this way you don’t have to use @ResponseBody annotation in your method even if your method doesn’t return any value.即When you don’t declare a ViewResolver, spring registers a default InternalResourceViewResolver which creates instances of JstlView for rendering the View.当你没有声明ViewResolver时，spring会给你注册一个默认的ViewResolver，其是JstlView的实例。它通过RequestDispatcher寻找资源（视图），不过这个资源也可能是Servlet，也就是说，Controller中方法返回字符串（视图名），也可能会解析成Servlet。当你的请求路径与视图名相同时，就会发生死循环。javax.servlet.ServletException: Circular view path [list]: would dispatch back to the current handler URL [/list] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.即If you are not returning a view. But only a JSON, adding @ResponseBody to the response helps returning a JSON value rather than a view.[https://stackoverflow.com/questions/18813615/how-to-avoid-the-circular-view-path-exception-with-spring-mvc-test] 目前我的情况是，@feignClient的接口定义每个request handler都必须要有@ResponseBody，否则就会报错误。但是别的Controller，定义时，完全不需要。不管是跨服务的，还是本服务的。","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring-cloud-feign","slug":"spring-cloud-feign","permalink":"http://yoursite.com/tags/spring-cloud-feign/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring-cloud","slug":"开源库/java/spring-cloud","permalink":"http://yoursite.com/categories/开源库/java/spring-cloud/"}]},{"title":"spring-cloud-config","date":"2018-09-17T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring-cloud/spring cloud config/","text":"eureka配合书上说的cloud-config-server需要eureka不属实，config-client已经指明了uri地址，必然可以得到信息，uri地址并非是一个借助eureka的URI。config-client，下面两句实现效果相同，但后者需要config-server注册在eurekaspring.cloud.config.uri=http://localhost:5500/与12spring.cloud.config.discovery.enabled=truespring.cloud.config.discovery.serviceId=spring-cloud-config-server 网站官网 官网 3 1 2345678 自动部署Spring Cloud config自动部署 pring Cloud config Spring Cloud热更新 JCEJava Cryptography Extension（JCE） 4 5","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring-cloud-config","slug":"spring-cloud-config","permalink":"http://yoursite.com/tags/spring-cloud-config/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring-cloud","slug":"开源库/java/spring-cloud","permalink":"http://yoursite.com/categories/开源库/java/spring-cloud/"}]},{"title":"spring-data","date":"2018-09-17T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring data/","text":"JPA问题一spring data jpa 出现Not a managed type@Entity才会被自动识别，【否则报错】不需要用@EnableJpaRepositories(value= {“com.hello.domain”}【注：Entity只能是db认可的数据类型，list之类的是不可以的，否则报错】[PersistenceUnit: default] Unable to build Hibernate SessionFactoryCaused by: org.hibernate.MappingException: Could not determine type for: java.util.List, at table: account, for columns: [org.hibernate.mapping.Column(expenses)] 问题二cannot load driver class: com.mysql.jdbc.Driverpom中缺少依赖 mysql mysql-connector-java runtime 问题三Spring Boot 下使用JPA，报Access to DialectResolutionInfo cannot be null when ‘hibernate.dialect’ not set解决办法，指定hibernate.dialect即可：1.如果配置文件格式为application.properties，在配置文件中添加以下代码即可：spring.jpa.database-platform=org.hibernate.dialect.MySQL5Dialect或者用：Adding the following line to the properties file solve this problem when I had that error.spring.jpa.database=mysql 概念区别IDorg.springframework.data.annotation.Id is currently used by Spring to support mapping for other non relational persistence databases or frameworks that do not have a defined common persistence API like JPA. So, it is normally used when dealing with other spring-data projects such as spring-data-mongodb, spring-data-solr, etc. javax.persistence.Id is the annotation defined by JPA for all its implementations. Have in mind JPA only applies for management of relational data. CURD和JpaJpaRepository extends PagingAndSortingRepository which in turn extends CrudRepository. Their main functions are: CrudRepository mainly provides CRUD functions.PagingAndSortingRepository provides methods to do pagination and sorting records.JpaRepository provides some JPA-related methods such as flushing the persistence context and deleting records in a batch.Because of the inheritance mentioned above, JpaRepository will have all the functions of CrudRepository and PagingAndSortingRepository. So if you don’t need the repository to have the functions provided by JpaRepository and PagingAndSortingRepository , use CrudRepository. redis网站1 2 3 4 5 6 官网 windows1 2 3","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring-data","slug":"spring-data","permalink":"http://yoursite.com/tags/spring-data/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"Spring-cache","date":"2018-09-17T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring cache/","text":"版本问题1 2 guavaspring-context-support 5.0.x就已放弃对guava cache。 4.3.x还支持。 （因为spring推荐使用caffeine取代guava）间接导致spring boot starter cache也不支持。 Caffeine是使用Java8对Guava缓存的重写版本，在Spring Boot 2.0中将取代Guava。 spring配合guava cache1 2 spELSpEL是包含关键字root的，所以你的method的parameter name不要是root。 否则报错Method concat(String) cannot be found on type CacheExpressionRootObject。 官方文档 memory cache自实现1 2 3 4 spring boot cacheCache库的选择 特性 使用 特性 4 memcached1 2","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring-boot-starter-cache","slug":"spring-boot-starter-cache","permalink":"http://yoursite.com/tags/spring-boot-starter-cache/"},{"name":"spring-cache","slug":"spring-cache","permalink":"http://yoursite.com/tags/spring-cache/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"spring-anotation","date":"2018-09-17T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring anotation/","text":"@Component Error creating bean with name ‘xxxx’ defined in file [xxx.class]: Unsatisfied dependency expressed through constructor parameter 0;","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring-anotation","slug":"spring-anotation","permalink":"http://yoursite.com/tags/spring-anotation/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"spring web","date":"2018-09-17T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring web/","text":"问题1MVC的@requestBody只有一个，你别传进去好几个requestBody，那肯定会报错@RequestBody 异常：Required request body is missing 测试JSON解析RestApi ‘Javascript Template Engine’. Generally JS template engines accept JSON data and render HTML from them. Frameworks like AngujarJS and VueJS also do this. 其他重定向123456789@RestControllerpublic class FooController &#123; @RequestMapping(&quot;/foo&quot;) void handleFoo(HttpServletResponse response) throws IOException &#123; response.sendRedirect(&quot;some-url&quot;); &#125;&#125; MVC controllerjson,jsp,dtojspjson1json2dtodto2dto3dto4dto5dto6dto6 exception1","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring web","slug":"spring-web","permalink":"http://yoursite.com/tags/spring-web/"},{"name":"spring mvc","slug":"spring-mvc","permalink":"http://yoursite.com/tags/spring-mvc/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"guava","date":"2018-09-17T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/guava/","text":"cache* expireAfterAccess: 当缓存项在指定的时间段内没有被读或写就会被回收。 * expireAfterWrite：当缓存项在指定的时间段内没有更新就会被回收,如果我们认为缓存数据在一段时间后数据不再可用，那么可以使用该种策略。 * refreshAfterWrite：当缓存项上一次更新操作之后的多久会被刷新。","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"guava","slug":"guava","permalink":"http://yoursite.com/tags/guava/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"}]},{"title":"Spring-boot","date":"2018-09-08T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/spring boot/","text":"版本更迭cloud与boot配合1 问题1@SpringApplicationConfiguration(classes = Application.class) 报错，注解不能导入。 有的说是这个注解在1.4就被替换1.5.2版本的，直接用@SpringBootTest就可以实现测试功能。 问题2spring-boot-starter-parent是一个特殊的starter,它用来提供相关的Maven默认依赖，使用它之后，常用的包依赖可以省去version标签。 并不是每个人都喜欢继承自spring-boot-starter-parent POM。您可能有您需要使用的自己的公司标准parent，或者您可能更喜欢显式声明所有的Maven配置。如果你不想使用spring-boot-starter-parent，您仍然可以通过使用scope = import依赖关系来保持依赖关系管理： 3spring boot—-springapplication not found—版本号问题 4spring boot—–root of context hierarchy—————问题是由于scope的属性配置问题，改成compile即可。 具体原因：由于scope为provided时该依赖是由系统组件提供的，我们不需要手动添加，它只存在于编译、运行和测试阶段，打包的时候并不会打进去，被剔除了的。而comile表示 dependency 都可以在生命周期中使用。而且，这些dependencies 会传递到依赖的项目中。适用于所有阶段，会随着项目一起发布。即依赖的项目会参与到当前项目的编译、运行、测试以及打包发布，是一个比较强的依赖范围。 问题一https://stackoverflow.com/questions/33301073/spring-boot-application-cant-resolve-the-org-springframework-boot-package/42998184解决方法和高票答案一致，降spring-boot-starter-parent版本 问题二could not extract ResultSet in hibernate原因不详。解决方法是：application.properties添加spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImplspring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl并且版本从1.3.7升级到1.4.3.不需要给@Entity的类添加@Table、@Column这些内容。 问题三报一些奇怪的错，比如：java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication 解决办法删除整个.m2目录，maven clean了一下重新下载的依赖 spring-boot-maven-pulginSpring Boot的Maven插件（Spring Boot Maven plugin）能够以Maven的方式为应用提供Spring Boot的支持，即为Spring Boot应用提供了执行Maven操作的可能。Spring Boot Maven plugin能够将Spring Boot应用打包为可执行的jar或war文件，然后以通常的方式运行Spring Boot应用。 Spring Boot Maven plugin的5个Goals spring-boot:repackage，默认goal。在mvn package之后，再次打包可执行的jar/war，同时保留mvn package生成的jar/war为.originspring-boot:run，运行Spring Boot应用spring-boot:start，在mvn integration-test阶段，进行Spring Boot应用生命周期的管理spring-boot:stop，在mvn integration-test阶段，进行Spring Boot应用生命周期的管理spring-boot:build-info，生成Actuator使用的构建信息文件build-info.properties org.springframework.boot spring-boot-maven-plugin clicloud boot","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Spring-boot","slug":"Spring-boot","permalink":"http://yoursite.com/tags/Spring-boot/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"Spring-Cloud","date":"2018-09-08T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring-cloud/spring cloud/","text":"问题cloud/boot的版本，带不带starter差别特别大！！完全就不是一个东西了。","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"http://yoursite.com/tags/Spring-Cloud/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring-cloud","slug":"开源库/java/spring-cloud","permalink":"http://yoursite.com/categories/开源库/java/spring-cloud/"}]},{"title":"Spring-Cloud-Admin","date":"2018-09-08T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring-cloud/spring cloud admin/","text":"简介Spring-Cloud-Admin 基于Spring Cloud微服务化开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理、网关API管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Spring-Cloud","slug":"Spring-Cloud","permalink":"http://yoursite.com/tags/Spring-Cloud/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring-cloud","slug":"开源库/java/spring-cloud","permalink":"http://yoursite.com/categories/开源库/java/spring-cloud/"}]},{"title":"JNA","date":"2018-09-05T15:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/jna/","text":"gitJava Native AccessJava Native Interface source地址help地址 C++的dllname mangling的处理，如何写才不会有这个问题。方法1 方法2 方法3 方法4 创建dll工程win10(x64)VS2013(x64—Release)Win32—-Win32 Project[选择dll] 千万不选择DLL(Universal Windows) function的定义，只有__decspec(dllexport)是必须的。 如果生成的function name是name mangling,那么他可能的序号是：和declare无关，和实现的顺序有关，且是逆序的。【这些没什么特别大的意义，还是得靠dependency walker来看顺序】 JNA的实际实现方法地址 JNA uses libffi, a magical native implementation that translates Java underneath JNA extracts a native DLL into the temporary folder and then loads When the process exits it kills that DLL. JNA用到 libffi 库，通过这个库将 需要调用的 DLL 库加载到一个临时文件，当使用完毕后，再释放 libffi 库。 然后，知道需要临时文件，那么就查找 JNA 的临时文件再哪？有两种情况：一是临时文件夹不存在；二是Java对临时文件夹没有写的权限。 那JNA的临时文件夹路径在哪呢？网上给出了这几个位置：%TMPDIR%/jna, system library load path, %TEMP%, Tomcat’s temp dir。 failed to create temporary file for jnidispatch: Java.IO.Exception: 系统找不到指定路径 at com.sun.jna.Native.loadNativeLibraryFromJar(Native.java:751) ## 1 2 3 4 5 6","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"jna","slug":"jna","permalink":"http://yoursite.com/tags/jna/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"}]},{"title":"idea","date":"2018-08-19T15:06:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/java/idea/","text":"1代码执行时的热点跟踪，判断什么部分最耗时，执行频次最高，——他们才是优化的对象 java喜欢用string名字，来生成某个具体实例 像C++的gui一样，xml生成，按照事先的规定，可以生成web.xml等 反射 final修饰class properties不要有空格，等号直接跟。也不需要引号来包含字符串。 pythontomcat在python相当于什么","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/tags/编程语言/"},{"name":"Idea","slug":"Idea","permalink":"http://yoursite.com/tags/Idea/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://yoursite.com/categories/编程语言/java/"}]},{"title":"vim","date":"2018-06-21T22:00:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/vim/","text":"配置文件.vimrc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677\" 开启文件类型侦测filetype on\" 根据侦测到的不同类型加载对应的插件filetype plugin on\" 开启实时搜索功能set incsearch\" 搜索时大小写不敏感set ignorecase\" 关闭兼容模式set nocompatible\" vim 自身命令行模式智能补全set wildmenu\" 禁止光标闪烁set gcr=a:block-blinkon0\" 禁止显示滚动条set guioptions-=lset guioptions-=Lset guioptions-=rset guioptions-=R\" 禁止显示菜单和工具条set guioptions-=mset guioptions-=T\" 辅助信息\" 总是显示状态栏set laststatus=2\" 显示光标当前位置set ruler\" 开启行号显示set number\" 高亮显示当前行/列set cursorlineset cursorcolumn\" 高亮显示搜索结果set hlsearch\" 禁止折行set nowrap\" 开启语法高亮功能syntax enable\" 允许用指定语法高亮配色方案替换默认方案syntax on\" 自适应不同语言的智能缩进filetype indent on\" 将制表符扩展为空格set expandtab\" 设置编辑时制表符占用空格数set tabstop=4\" 设置格式化时制表符占用空格数set shiftwidth=4\" 让 vim 把连续数量的空格视为一个制表符set softtabstop=4\" 基于缩进或语法进行代码折叠\"set foldmethod=indentset foldmethod=syntax\" 启动 vim 时关闭折叠代码set nofoldenable 命令光标移动 h或退格: 左移一个字符； l或空格: 右移一个字符； j: 下移一行； k: 上移一行； ​ +或Enter: 把光标移至下一行第一个非空白字符。 -: 把光标移至上一行第一个非空白字符。 w: 前移一个单词，光标停在下一个单词开头； W: 移动下一个单词开头，但忽略一些标点； e: 前移一个单词，光标停在下一个单词末尾； E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点； b: 后移一个单词，光标停在上一个单词开头； B: 移动到上一个单词开头，忽略一些标点； (: 前移1句。 ): 后移1句。 {: 前移1段。 }: 后移1段。 fc: 把光标移到同一行的下一个c字符处 Fc: 把光标移到同一行的上一个c字符处 tc: 把光标移到同一行的下一个c字符前 Tc: 把光标移到同一行的上一个c字符后 ;: 配合f &amp; t使用，重复一次 ,: 配合f &amp; t使用，反向重复一次 0: 移动到行首。 ^: 移动到本行第一个非空白字符。 $: 移动到行尾。j n|: 把光标移到递n列上。 nG: 到文件第n行。 :n 移动到第n行。 :$ 移动到最后一行。 H: 把光标移到屏幕最顶端一行。 M: 把光标移到屏幕中间一行。 L: 把光标移到屏幕最底端一行。 G: 到文件尾部。 [[: 跳转到上一个函数块开始，需要有单独一行的{。 ]]: 跳转到下一个函数块开始，需要有单独一行的{。 []: 跳转到上一个函数块结束，需要有单独一行的}。 ][: 跳转到下一个函数块结束，需要有单独一行的}。 [{: 跳转到当前块开始处； ]}: 跳转到当前块结束处； [/: 跳转到当前注释块开始处； ]/: 跳转到当前注释块结束处； %: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。 gj: 移动到一段内的下一行； gk: 移动到一段内的上一行； ge: 后移一个单词，光标停在上一个单词末尾； gE: 同 ge ，不过‘单词’包含单词相邻的标点。 g0: 移到光标所在屏幕行行首。 g$: 移动光标所在屏幕行行尾。 gg: 到文件头部。 g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。 gd: 跳转到局部变量的定义处； gD: 跳转到全局变量的定义处，从当前文件开头开始搜索； g;: 上一个修改过的地方； g,: 下一个修改过的地方； 常用技巧多行处理先对某行进行操作，比如加注释I//&lt;ESC&gt;（再比如删除注释2x 别画蛇添足用多个ESC），然后用v选中一个区域，按下:键，最下面会出现:&#39;&lt;,&#39;&gt;，再输入normal.就可以执行了。 因为.命令会记住上一次的操作。 跳转不要用命令行:n来跳转第n行，而是用nG来做。 优点是，可以用来做来回跳转。！！！ 或者用ctl+o去上一个，或者用ctrl+i去下一个。 nl光标向右移动n列。 n|光标移动到当前行的第n列。 f之后，跟个任意字母，会跳到第一次出现该字母的位置。 shell命令不离开vim，执行bash指令，然后可以再返回。 :!ls -l，:!go test xxx之类的。 快捷键shift+～是大小写转换。","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"postman && curl","date":"2018-06-21T22:00:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/network/postman/","text":"postman[视窗软件]对应关系 MVC postman @RequestParam url右边有个params按钮，来输入的 实际转换成URL， “?x=y&amp;xx=yy&amp;xxx=yyy” @RequestBody 下面的Body标签输入 对应form @RequestHeader 下面的Header标签输入 对应http头部 curl[命令行]处理Http Authenticationcurl --user name:password http://ww.example.com","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"postman","slug":"postman","permalink":"http://yoursite.com/tags/postman/"},{"name":"curl","slug":"curl","permalink":"http://yoursite.com/tags/curl/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"network","slug":"工具/network","permalink":"http://yoursite.com/categories/工具/network/"}]},{"title":"grammar","date":"2018-06-12T15:41:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/java/grammar/","text":"1123456case 1:case 2:case 3:case 4: Console.WriteLine(&quot;ok!**********&quot;); break; case 5: Console.WriteLine(&quot;wrong!*******&quot;); break; file处理 file处理2 List和Collection一样，本身是interface，需要赋值的是派生类。 static、final等关键词含义 static修饰函数是否指，静态函数，与C++有何区别。java的似乎也无法static函数使用non-static的成员变量 final似乎和lambda的引用本地变量有关系。 vector、arraylist区别 junit范例 java8的lambda配合thread123Runnable task = ()-&gt;&#123;...&#125;;Thread thread = new Thread(task);thread.start(); 编码/*IO流-转换流的字符编码转换-ISO-8859-1和utf-8和GBK互转 编码:字符串变成字节数组 解码:字节数组变成字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122String--&gt;byte[]: str.getBytes(); byte[] getBytes(Charset charset) 使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。 byte[] --&gt;String : new String(byte[]) String(byte[] bytes, String charsetName) 通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。*/import java.uitl.*;class EncodeDemo&#123; public static void main(String[] args) throws Exception &#123; String s = &quot;你好&quot;; byte[] b1 = s.getBytes(&quot;GBK&quot;);//编码:字符串变成字节数组 输入 参数（编码表） System.out.println(Arrays.toString(b1));//打印 数组变成字符串 String s1 = new String(b1,&quot;ISO8859-1&quot;);//解码:字节数组变成字符串,String参数(数组,编码表) 输出 System.out.println(&quot;s1=&quot;+s1); //对s1进行iso8859-1编码 byte[] b2 = s1.getBytes(&quot;ISO8859-1&quot;);//拿乱码的字符串重新编码成字节数组,输入 参数（编码表） System.out.println(Arrays.toString(b2));//打印 数组变成字符串 String s2 = new String(b2,&quot;gbk&quot;);//解码:字节数组变成字符串,String参数(数组,编码表) 输出 System.out.println(&quot;s2=&quot;+s2); &#125;&#125;//ISO8859-1和GBK互转 不会出乱码 //utf-8和GBK互转会出乱码，参考其他文章，如下/*GBK编码是一个中文2个字节，而UTF-8编码是一个中文3个字节，当我们调用getBytes(&quot;UTF-8&quot;)方法时，会通过计算来增加字节。正常的情况下是两个两个的转化，但是当字节是奇数时最后1个字节转字符就会计算错误，然后直接赋予最后这个字符为?。所以我们需要创建ISO-8859-1编码的字符串，保证一个输入只有一个输出。*/import java.io.UnsupportedEncodingException;public class new_122 &#123;public static void main(String[] args) throws UnsupportedEncodingException &#123; String gbk =&quot;我来了&quot;; String iso = new String(gbk.getBytes(&quot;UTF-8&quot;),&quot;ISO-8859-1&quot;); //构造方法 String(byte[] bytes, Charset charset) // 通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。 //方法 返回byte[]： getBytes(Charset charset) // 使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。 //构造方法里面，再加了方法，就是先编码字节数组用UTF-8，再解码字符串用ISO-8859-1 System.out.println(new String(iso.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;)); //构造方法里面，再加了方法，就是先编码字节数组用ISO-8859-1，再解码字符串用UTF-8 //总结，用ISO-8859-1做中介编码表 来 实现UTF-8 和GBK 互转，因为ISO-8859-1是单字节的，不会改变数据 &#125;&#125; ### java的static method没法创建private class。static main可以创建自己。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"grammar","slug":"grammar","permalink":"http://yoursite.com/tags/grammar/"},{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/tags/编程语言/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://yoursite.com/categories/编程语言/java/"}]},{"title":"eclipse","date":"2018-05-28T22:00:54.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/工具/IDE/eclipse/","text":"plugin反编译插件方法 Spring开发插件方法 problemfont新安装的eclipse中文注释字体太小，解决方法如下：打开Elcipse——&gt;点击菜单栏上的“Windows”——&gt;点击“Preferences”——&gt;点击“Genneral”——&gt;点击“Appearance”——&gt;点击“Colors and Font”——&gt;在右侧框展开“Basic”文件夹——&gt;双击“Text Font”——&gt;在弹出窗选择“Courier New” 而Courier New这种字体可能找不到，如下：点击字体选择框左下角的“显示更多字体”链接来打开设置字体的控制面板，找到“Courier New”，右键选择“显示”即可激活该字体。此时，关闭打开的窗口，重新打开eclipse的windows，就可以选择“Courier New”。 create maven projecteclipse创建maven项目，鼠标所选中的workspace会影响project的位置，选择好再ctrl+N.否则就会一直报错，覆盖项目。 java-jdk-jre环境变量系统变量ClassPath应该是,;不需要别的乱七八糟的东西Path需要%Java_Home%","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://yoursite.com/tags/Eclipse/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"elastic-job-lite","date":"2018-05-28T21:45:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/elastic-job-lite/","text":"preparementgit 编译错误lombok的eclipse安装方法 PowerShell后台执行ZooKeeperStart-Job -ScriptBlock { sleep 5 } web端打包流程 runspring装配后，用ApplicationContext加载下xml文件，就可以启动了。既可以在test文件夹下写class，用mvn test启动。也可以在main文件夹下写main方法，用mvn -Dexec启动 examplediverse分4片。只有2路，分别处理奇偶索引， 因为是一次性执行所有分片，导致每次都有1对是重复作业。如何避免。 elastic-console注册中心配置 注册中心地址———server-lists 命名空间————-namespace这两个设定相一致，其他无所谓。否则无法显示作业 1.4 配置eclipse的mavenhttps://www.cnblogs.com/tangshengwei/p/6341462.html https://www.cnblogs.com/pengyan-9826/p/7767070.html https://blog.csdn.net/anialy/article/details/8226887 croncron表达式 在线编辑器 简介 问题先把log文件生成arraylist，每个string都是一条完整的日志记录。 —–放在ctor，有别的吗？ dataflow对每个string进行分类，并存入相应的文件。 分片按照arraylist的idx来进行，确保不会有出现重复处理。—-有别的方式吗？ 为什么要任务分片，分片需要执行多久才合适？ 比如说，我把200大小的数组，分给4片去处理，如果不用分片id，上来就是1-50-100-150-200，让分片一次性处理完？？ 或者使用分片id，每次只处理1个，1234，5678，4个4个的处理完所有。分片是为了利用多核或者分布式系统吗？？ 分片什么时候回来轮训说，再处理一次？？ 大文件无法读入内存，该如何处理。 zookeeper是个管理分布式系统的东西。 不是问题的问题12345678!!![jcc][t4][2030][11211][3.69.24] 在对连接的底层 socket、socket input stream 或 socket output stream 执行操作期间 发生通信错误。错误位置：Reply.fill() - socketInputStream.read (-1)。消息：Software caused connection abort: recv failed。 ERRORCODE=-4499, SQLSTATE=0800!!![jcc][t4][10335][10366][3.69.24] 操作无效：连接已关闭。 ERRORCODE=-4470, SQLSTATE=08003 这个问题是突然出现的，但是dataflow的任务都能正常执行，就是会报这个错误。我已开始认为这个可能会导致任务执行不完全，比如执行到一半，后续的都被舍弃掉了，所以对他进行了错误检查处理。 最后是通过重启电脑，解决了该问题 怀疑是job没有被正常的启动，因为我感觉我修改了cron表达式，job并没有按照我预想的逻辑执行。——无解，这个cron我还是没能解决 怀疑是AppData/Temp文件中又不干净的内容，因为我发现ZkServer居然会缓存一些内容，每次我重启zkServer他能保留之前的信息，我怀疑信息是在这里—–删除了也仍然报错 怀疑是job逻辑出问题——-但工作都是正常的 突然发现zkserver一直抱一个错（xid:0x10 txntype:-1 reqpath:n/a Error Path:/dd-job/myDataFlowJob8/instances Error:KeeperErrorCode = NoNode for /dd-job/myDataFlowJob8/instances）。怀疑是这个问题，但实际上我起一个普通的simplejob仍然有该问题——-实际应该是由于我是单机运行，zookeeper没办法分配job。 怀疑是3分片，导致的多线程对文件的争夺写入。但是用sync来控制仍然会报错。 1http://elasticjob.io/docs/elastic-job-lite/01-start/dev-guide/ https://my.oschina.net/u/719192/blog/506062 https://www.cnblogs.com/haoxinyue/p/6919375.html https://my.oschina.net/u/719192/blog/506062 https://github.com/elasticjob/elastic-job-lite https://www.jianshu.com/p/a518dd3229de https://www.jianshu.com/p/14f86c6efe22 https://www.jianshu.com/p/e0e7e8494d96 https://stackoverflow.com/questions/34183503/eclipse-maven-2-installation http://www.codes51.com/itwd/4194401.html https://cn.bing.com/search?q=eclipse+Target+is+not+a+Maven+Home&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;pq=eclipse+target+is+not+a+maven+home&amp;sc=0-34&amp;sk=&amp;cvid=E8CE2D27333F4E0FBDE616332FD38A97 https://blog.csdn.net/hhhccckkk/article/details/10458159 https://cn.bing.com/search?q=eclipse+git+clone&amp;form=%20PRLNC1&amp;src=IE11TR&amp;pc=LCTE https://blog.csdn.net/hhhccckkk/article/details/10458159 http://www.cnblogs.com/lpshou/archive/2013/07/18/3199243.html https://blog.csdn.net/Qiufeng_0ng/article/details/54427795 一个业务系统的后台可能存在很多不同种类、不同粒度的周期性任务，这些任务在分布式环境会遇到以下问题： 1、任务执行的单点问题：一台服务宕了，正在运行的任务也停止了。 2、任务执行的负载问题：一个大的任务只能跑在一台机器上，如何跑在多台服务器上并且同时不会被重复执行。 3、任务如何弹性扩容缩容？ 本课题旨在解决以上问题。 sharding1–1 2–2 0–0 0–3 1–5 2–7 0–6 1–8 2–10 0–9 1–11 2–12 0–12 1–14 2–16 0–15 1–16 2–18 0–18 1–20 2–21 0–21 1–22 2–23 分片感觉是我对 分片、多服务器、定时、任务，这3个糅合在一起产生了误解。 每次闪一下，是因为我设定的cron表达式含义为5s执行一次，即定时，而不是轮询判断当前分片来去选择执行，这也能解释一开始的问题，任务到底设置成什么样，是1次全执行完，还是分几次这样一闪一闪，答案是前者。他不是借助多服务来人一个大任务分片这样一闪一闪的执行多次。那就是另一个问题，如果任务阻塞了怎么办？有的任务很耗时（或某个时刻有太多任务要执行），导致其他任务分片迟迟得不到服务器去执行。 按照在单机（只有一个zookeeper）上运行3个分片，2个任务（1个每5s，一个每10s）。观察到并得出的结论： 各任务各分片各执行次数，线程id不同，但不同次数偶尔会出现id重复（第一次33-38，第二次39-41，第三次42-47，第四次48-50） 流处理不是所有分片的get的内容汇聚在一起统一处理，而是在各自线程中get完后，就自行处理。 线程都是并行的，每个步骤（取数据，拿数据，修改内容等等）的时间线彼此交织，并不固定，所以不能用一个线程公有变量进行内容控制，否则会有意想不到的执行，如果用mutex严格限定，又降低了效率 我第一次ctr+C中断，修改除了jobID以外的内容，重新运行，发现他仍然执行之前的逻辑，即jobID不更新，新的业务逻辑不会被分配，ctr+C没法再regCenter中删除该信息 读文件是采用的是先在ctor中把内容读成array再处理，写文件时出现3个线程同时往相同文件写【之前因为每次job只写1条，速度太快可能没太大影响】，这次直接报错【在对连接的底层 socket、socket input stream 或 socket output stream 执行操作期间 发生通信错误。错误位置：Reply.fill() - socketInputStream.read (-1)。消息：Connection reset by peer: socket write error。 ERRORCODE=-4499, SQL STATE=08001】 springxml文件注释，&lt;!-- --&gt;， 不要另起一行，直接在首末添加 context:component-scan spring可以自动去扫描base-pack下面或者子包下面的java文件，如果扫描到有@Component @Controller@Service等这些注解的类，则把这些类注册为bean context:property-placeholder elastichttps://www.jianshu.com/p/e0e7e8494d96 https://www.jianshu.com/p/af35eb69e52f https://www.jianshu.com/p/dd3c5b7d7694 https://www.jianshu.com/p/a9458887739d https://www.jianshu.com/p/c47bf61039f3 https://www.jianshu.com/p/9907fa17f4a6 http://elim.iteye.com/blog/2406211 elastic-codehttps://www.jianshu.com/p/65cee9864d42 https://www.jianshu.com/p/d442390ac3d1 https://www.jianshu.com/p/058051ba8204 https://www.jianshu.com/p/a7e291f3049b sockethttp://wiki.jikexueyuan.com/project/java-socket/socket-tcp-deadlock.html elastic dumphttps://blog.csdn.net/zhaosensenyy/article/details/51864096 https://blog.csdn.net/tanga842428/article/details/52885998 https://blog.csdn.net/agony_sun/article/details/77480109 http://www.cnblogs.com/shanyou/p/3221990.html https://blog.csdn.net/top_code/article/details/51377632","tags":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"},{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"},{"name":"elastic-job-lite","slug":"elastic-job-lite","permalink":"http://yoursite.com/tags/elastic-job-lite/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"}]},{"title":"maven project","date":"2018-05-28T21:45:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/java/maven/","text":"jdk、jre在mvn的配置mvn报错Maven error :No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?解决方式 mvn中央库的几个http://central.maven.org/maven2/com/ eclipse创建maven项目 ctrl+N,maven project simple project (skip archetype selection) workspace location add projects to workding set pom.xml Dependencies-&gt;Dependencies 中间可以搜索 然后alt+f5更新 maven更新总重置jdk解决方法 因为被重置导致本版本过低，报错 Build path specifies execution environment J2SE-1.5. There are no JREs installed in the workspace that are strictly compatible with this environment. 写class ctrl+N,spring bean configuration file 配置Bean java中的xml路径 mysql-connector-java的版本5开头合适，8的2018年没法用 添加依赖创建 添加依赖-报错修复 运行mvn test用junit写的test，没有main的method，可以直接运行 mvn exec:java -Dexec.mainClass=&quot;helloworld.Test&quot;该heloword.Test是个class，里面有main这个method，指定运行。 介绍 概念p-namespace和c-namespace pareent、module、import、properties eclipse从git导入maven项目maven国内镜像 maven环境配置 方法1方法2方法3 commandmvn命令 mvn创建war mvn运行main的3种方式 mvn testmvn -Dtest=classname test How to fix MojoFailureException while using spring roo to build web project 去看文件/target/surefire-reports (usual the the the bigger files contains a problem) project1怎么样才能不修改我的代码，直接修改配置文件ApplicationContext.xml，就能加载别人写的类，在我的程序中生成UserDaoImpl对象呢？ 1 首先你必须将别人的jar包引入到自己项目的classpath当中。2.1 如果别人的类有相应的注解，例如@Component，@Controller，@Repository，@Service这样的spring注解和@Resource之类的javax注解。则在ApplicationContext.xml中添加&lt;context:component-scan base-package=”xx.xx.xx”/&gt;就可以引入。xx.xx.xx是别人jar包中的包命名。2.2 如果别人的类没有相应的注解，则在bean配置中class选择别人的类即可。2.3 还有一种方法，就是你写一个包装类，将别人的类当作你包装类的属性，在bean配置中，采用property的方式引入。 可以在maven中添加相关的依赖。 2创建的某个maven project打包成jar，另一个maven project想引用其某个class，什么方式比较好【目前采取的是mvn install】 介绍 maven项目是不是不能用build path中手动添加jar，否则mvn命令无法识别。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"},{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"java","slug":"编程语言/java","permalink":"http://yoursite.com/categories/编程语言/java/"}]},{"title":"go经验","date":"2017-10-23T15:44:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/go/go经验/","text":"小项目—echo输入流、字节数组buf、 123456789101112131415161718192021sca := bufio.NewScanner(os.Stdio)scan.Scan()s string = scan.Text()b := []byte(s)bb := make([]byte,1024)conn = net.Connconn.Write(b)conn.Read(bb)rd := bufio.NewReader(conn)str, err := rd.ReadString('\\n')rd.Read()wr := bufio.NewWriter(conn)wr.Write()wr.Flush()io.Copy(conn, conn) 服务端，客户端1234567891011121314151617181920// 地址var tcpAddr *net.TCPAddrtcpAddr, err = net.ResolveTcpAddr(\"tcp\", \"localhost:9999\")// 客户端conn, err := net.Dial(\"tcp\", \"localhost:8888\")connptr, err := net.DialTCP(\"tcp\", nil, tcpAddr)// 服务端ln, err := net.Listen(\"tcp\", \":9999\")ln, err := net.ListenTCP(\"tcp\", tcpAddr)conn, err := ln.Accept()connptr, err := ln.AcceptTCP()// 连接conn := make(net.Conn)conn.localAddr()conn.RemoteAddr()conn.Close() 经验 package问题。一个文件夹下，所有go文件的package name都应该相同！！！否则无法执行go install/test会报错can&#39;t load package。 不允许嵌套定义函数。（会出现报什么”expected xx, found xxx”这种看不懂的错）。允许定义类似lambda这种匿名函数。参考 s 字节数组Buffer.Bytes()返回[]byte var b []byte，他的b.String()返回string 1234567891011b := make([]byte,1024)// illegal rune literalb[0] = '0x00'// cannot use \"0x00\" (type string) as type byte in assignmentb[0] = \"0x00\"// OKb[0] = 0x00b := []byte(s) 修改方法一因为fmt.Fprinft需要io.Writer。 所以自定义一个func (p *ByteSlice) Write(data []byte) (n int, err error)。 然后就可以用字符串的方式，修改字符数组。 我的思路仍然停留在覆盖在原有的数组内容，但是go语言，似乎喜欢的是append。所有我看到的文档，都是用append操作。即先不申请固定长度的数组，然后对其赋值。而是用个slice，一点点的扩张。 12345678910111213141516171819202122232425262728293031323334353637type ByteSlice []bytefunc (p *ByteSlice) Write(data []byte) (n int, err error) &#123; slice := *p // 旧思路-----覆盖原先内容 //for i:=0; i&lt;len(data); i++ &#123; // slice[i] = data[i] //&#125; // go的思路------apppend l := len(slice) if l + len(data) &gt; cap(slice) &#123; // 重新分配 // 为了后面的增长，需分配两份。 newSlice := make([]byte, (l+len(data))*2) // copy 函数是预声明的，且可用于任何切片类型。 copy(newSlice, slice) slice = newSlice &#125; slice = slice[0:l+len(data)] for i, c := range data &#123; slice[l+i] = c &#125; *p = slice return len(data), nil &#125;var b ByteSlicefmt.Fprintf(&amp;b, \"This hour has %d days\\n\", 7)// 必须是一个字节一个字节的写。\\0也可以用\\x来替代fmt.Fprintf(&amp;b, \"\\000\\x5a\")fmt.Printf(\"output: %x\\n\", b)fmt.Printf(\"output: %x\\n\", string(b)) 方法二用bytes包。 用Write则参数要求是slice，用WriteString参数要求是string。 仍然是Append操作。 123456var b []bytebuf := bytes.NewBuffer(b)buf.WriteString(\"\\x00\\x10\\x10\\x00\")fmt.Printf(\"output: %x\\n\", buf.String()) 转换方法一位操作 12b := make([]byte, 1024)var i int = (int(b[0])&lt;&lt;8 | int(b[1])) ####方法二 用strconv包提供的函数 []byte(strconv.Itoa(intParam))只支持int型。 方法三用encoding/binary包提供的函数 12345678910111213141516171819import \"encoding/binary\"// 大端序：从左往右读// 小端序：从右往左读var i int64 = 2323buf := Int64ToBytes(i)ii := BytesToInt64(buf)func Int64ToBytes(i int64) []byte &#123; var buf = make([]byte, 8) binary.BigEndian.PutUint64(buf, uint64(i)) return buf&#125;func BytesToInt64(buf []byte) int64 &#123; return int64(binary.BigEndian.Uint64(buf))&#125; 切片、数组范例解释 切片，本身是一种抽象，可以理解为一个“对象”，你对他可以不断赋值新的数组范围，—–即“值传递”。 12bb := b[2:6]bb = []byte&#123;0x00, 0x00, 0x10,0x00&#125; 但当你用下标来修改元素时，或者append操作，他就是“引用传递”。 切片不允许对其做一大段赋值，比如说 1bb = 0x00001000 12345678var b [1024]byte//传参// Fail--------把[1024]byte给[]byte不行，后者是slice，前者是array。类型不同bytes.NewBuffer(b)// OKbytes.NewBuffer(b[:]) GoSpec: the parameters of the call are passed by value! map/slice/chan 都是传值, 不是传引用 map/chan 对应指针, 和引用类似 slice 是结构体和指针的混合体 slice 含 values/count/capacity 等信息, 是按值传递 slice 中的 values 是指针, 按值传递 按值传递的 slice 只能修改values指向的数据, 其他都不能修改 以指针或结构体的角度看, 都是值传递! ##输出 官方 123456789101112131415161718192021222324%v // the value in a default format when printing structs, the plus flag (%+v) adds field names%#v // a Go-syntax representation of the value%T // a Go-syntax representation of the type of the value%% // a literal percent sign; consumes no value// Boolen%t the word true or false// Integer%b base 2%c the character represented by the corresponding Unicode code point%d base 10%o base 8%q a single-quoted character literal safely escaped with Go syntax.%x base 16, with lower-case letters for a-f%X base 16, with upper-case letters for A-F%U Unicode format: U+1234; same as \"U+%04X\"// String and slice of bytes (treated equivalently with these verbs):%s // the uninterpreted bytes of the string or slice%q // a double-quoted string safely escaped with Go syntax%x // base 16, lower-case, two characters per byte%X // base 16, upper-case, two characters per byte","tags":[{"name":"语言","slug":"语言","permalink":"http://yoursite.com/tags/语言/"},{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"},{"name":"experience","slug":"experience","permalink":"http://yoursite.com/tags/experience/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"go","slug":"编程语言/go","permalink":"http://yoursite.com/categories/编程语言/go/"}]},{"title":"go环境","date":"2017-10-23T15:44:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/go/go环境/","text":"IDEgo—工具 ​ def ​ code ​ imports ​ rename ​ lint ​ types ubuntu安装ubuntu安装sudo apt install golang-go 否则也可参考官方git 123$ sudo add-apt-repository ppa:gophers/archive$ sudo apt update$ sudo apt-get install golang-1.9-go 环境12345vim ~/.bash_profileexport GOPATH=$HOME/workexport GOBIN=$HOME/work/binsource ~/.bash_profile command–gocommand–其他 command–go 编译然后默认的go install就是在该GOPATH中你的src/xxx 你只需要go install xxx就可以了。 运行go install生成的可执行文件默认就在GOBIN中。 然后运行时只需要命令$GOBIN/xxxx就可以了。 自定义库和install一样的默认位置，go build xxx即可。 不生成任何文件，只有在go install某个程序时，且引用到了这个库，就会在GOPATH/pkg/中有对应的xxx.a文件。 别人的库remote package 本地GOPATH有，就不管了，没有就会下载并编译。 go get github.com/golang/example/hello 在文件中可以用，来引用远程库 1import \"github.com/golang/example/stringutil\" 测试go test默认回去找文件名为xxx_test.go中的函数名为TestXXXX的去执行。 go有个测试框架，示例如下 1234567891011121314151617import \"testing\"func TestReverse(t *testing.T) &#123; cases := []struct &#123; in, want string &#125;&#123; &#123;\"Hello, world\", \"dlrow ,olleH\"&#125;, &#123;\"Hello, 世界\", \"界世 ,olleH\"&#125;, &#123;\"\", \"\"&#125;, &#125; for _, c := range cases &#123; got := Reverse(c.in) if got != c.want &#123; t.Errorf(\"Reverse(%q) == %q, want %q\", c.in, got, c.want) &#125; &#125;&#125; organization WorkSpace src———GO source files repository 1 package 1 x.go xx.go package 2 repository 2 package 1 package 2 pkg——–package objects directory 1 xx.a———————-一般是我们自己定义的/引用的pkg bin———executable commands","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"},{"name":"语言","slug":"语言","permalink":"http://yoursite.com/tags/语言/"},{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"go","slug":"编程语言/go","permalink":"http://yoursite.com/categories/编程语言/go/"}]},{"title":"IntelliJ","date":"2017-10-20T23:39:54.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/工具/IDE/IntelliJ/","text":"其他参考文献 特色功能ctrl+alt+shift+u可以轻松画出当前class的UML图右键点击UML图，还可以添加Show Dependencies,Show categories 不需要快捷键来定位当前文件所属位置，在toolbar下面，就是当前文件的完整路径。 自带jad，反编译。 代码补足intellij代码缩写功能还可以通过live templates来自定义。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码例如要输入for(User user : users)只需输入user.for+Tab再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。代码标签输入完成后，按Tab，生成代码。 快捷方式一（光标移到该代码行，Alt+Enter），可以异常外抛出，也可以try-catch快捷方式二（光标移到该代码行，或者选中该行代码，Ctrl+Alt+T）","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"IntelliJ","slug":"IntelliJ","permalink":"http://yoursite.com/tags/IntelliJ/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"library 和 framework","date":"2017-10-18T23:44:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/java/spring/library&framework/","text":"比较我原先对于框架的认识： 先觉得flask【2016.05】这样，我需要按照MVC模式去写一些东西，比如view、model等内容，然后他最外面的Flask这个大class，会把所有的blueprint、sqlAlchemy等内容全部都聚集在一起。 再到看到scrapy框架【2017.05】，我觉得就是骨架已经被它搭建好了，中间引擎，左边url输入，加一些re，右边导出到mysql，总之就是只要填充一点点血肉和目的地信息，“汽车”就能自动发动，完成功能。（spider、item、pipeline等组件） 再到brpc框架【2017.09】，只以echoService为例。服务端和客户端都以protobuf的header基础下【客（request、response）服（serviceImpl），通过brpc的【客（controller）服（server）】建立起联系。然后互相通信。 再由muduo库【2015.09】，我觉得C++这门语言，用框架和用库，他们的区别大吗？若单论业务逻辑，没啥区别，但底下的东西就差很多了，brpc框架有监控等厉害功能。我说不上来，但我觉得差别既小又大。 直到我看了Spring【2017.10】这个框架，我觉得真的是java的框架逼格好高，我一开始以为他是flask这种的，再后来觉得她是scrapy这种，有成熟的事件驱动，最后发现，它似乎比我在上面看到的几种，都要来的复杂和特别，我觉得这又让我见识到了框架，原来是有设计思想在里面的（比如类注入），不是简单的有骨架填血肉那么简单。 再由qt框架【2015.11】，我可能用习惯了GUI软件，没觉得他是一个多么了不起的内容，觉得习以为常，但其实他的signal和slot机制，本就是一个框架的亮点（未解决某个设计模式而提出的一种机制，就是上面的“类注入”一样），他的UI文件生成C++代码这个功能也是框架的一部分，他的main函数的运行等等。我用的时候没感觉，现在结合Spring给我的感觉，我认为框架真的是个了不起的东西。","tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"java","slug":"开源库/java","permalink":"http://yoursite.com/categories/开源库/java/"},{"name":"spring","slug":"开源库/java/spring","permalink":"http://yoursite.com/categories/开源库/java/spring/"}]},{"title":"flask","date":"2017-10-08T07:27:14.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/开源库/python/flask/","text":"jinja2需求传递参数给template。这是flask做的。方法如下： 所有的本地参数 1234567@app.route('/')def index(): content = \"\"\" teste \"\"\" user = \"Hero\" return render_template('index.html', **locals()) 指定某几个 12def index() : return render_template('index.html', obj = \"object\", data = \"a223jsd\" ); 需求一我的“图书馆”功能，对于章节页、书页都希望能有个模板来做，能实现吗？ 因为我的整个章节页比如我会扩展或删除他的index的内容，一个个调整好累。 搭配extends和block功能实现。中文官方文档 基本模板： 12345678910111213141516&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;My Webpage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;navigation&quot;&gt; &#123;% for item in navigation %&#125; &lt;li&gt;&lt;a href=&quot;&#123; &#123; item.href &#125;&#125;&quot;&gt;&#123; &#123; item.caption &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;h1&gt;My Webpage&lt;/h1&gt; &#123; &#123; a_variable &#125;&#125;&lt;/body&gt;&lt;/html&gt; 子模板： 1234567891011121314&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;Index&#123;% endblock %&#125;&#123;% block head %&#125; &#123; &#123; super() &#125;&#125; &lt;style type=&quot;text/css&quot;&gt; .important &#123; color: #336699; &#125; &lt;/style&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;h1&gt;Index&lt;/h1&gt; &lt;p class=&quot;important&quot;&gt; Welcome on my awesome homepage. &lt;/p&gt;&#123;% endblock %&#125; 对于block是可以重复使用的，比如说。 123&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - &#123; &#123; sitename &#125;&#125;&lt;/title&gt;&lt;!--.. . snip.. . --&gt;&lt;h1&gt;&#123; &#123; self.title() &#125;&#125;&lt;/h1&gt; 需求二我的书页内，需要放所有的章节的链接，但我一个个写，非常不利于我后面修改endpoint之类时的改动，能用循环处理，我替代一些关键词吗？？ 12345&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&#123; &#123; url_for(&apos;readerBook.reader_content&apos;, bookName= &apos;LittlePrince&apos;, chapterNumber=1) &#125;&#125;&quot; title=&quot;Chapter1&quot; target=&quot;_blank&quot;&gt;Chapter 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&#123; &#123; url_for(&apos;readerBook.reader_content&apos;, bookName= &apos;LittlePrince&apos;, chapterNumber=2) &#125;&#125;&quot; title=&quot;Chapter2&quot; target=&quot;_blank&quot;&gt;Chapter 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&#123; &#123; url_for(&apos;readerBook.reader_content&apos;, bookName= &apos;LittlePrince&apos;, chapterNumber=3) &#125;&#125;&quot; title=&quot;Chapter3&quot; target=&quot;_blank&quot;&gt;Chapter 3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 变成 12345&lt;UL&gt; &#123;% for i in range(27) %&#125; &lt;li&gt;&lt;a href=&quot;&#123; &#123; url_for(&apos;readerBook.reader_content&apos;, bookName= &apos;LittlePrince&apos;, chapterNumber=i) &#125;&#125;&quot; title=&#123; &#123; &quot;Chapter&quot; + i | string &#125;&#125; target=&quot;_blank&quot;&gt;&#123; &#123; &quot;Chapter&quot; + i | string &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125;&lt;/UL&gt; 这里面用到了： for循环可以是遍历外来的dict变量，也可以是语句range 对于变量可以用myOldIntValue|string，或者myOldStrValue|int来转换。 出现一个问题就是render_tempaltes传递过来的参数好像都会被退化成string，不知道是不是我的错觉。 在{ { }}不支持表达式。然后我只能写成 1234&#123;% if chapterNumber != &apos;1&apos; %&#125; &#123;% set pre = chapterNumber|int-1 %&#125;&lt;p class=&quot;nextpage&quot;&gt;Pre：&lt;a href=&quot;&#123; &#123; url_for(&apos;readerBook.reader_content&apos;, bookName= bookName, chapterNumber=pre) &#125;&#125;&quot;&gt;&#123; &#123; &quot;Chapter &quot; + pre | string &#125;&#125;&lt;/a&gt;&lt;/p&gt;&#123;% endif %&#125; ​ flask-script之前我没用dokcer开发时，我记得不支持我本地修改文件，不用重新运行runserver。 现在怎么我本地修改，我浏览器直接重新刷新，我的修改内容能立马显示———–额！！！我修改的是html文件，不是py。难怪呢！！！我测试过了，用debug模式的启动，可以实现不用restart就能直接测试修改过的py文件。非常的方便，我只要尽情去调整我的全部内容即可。很棒！！！","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"},{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"Web开发","slug":"Web开发","permalink":"http://yoursite.com/tags/Web开发/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"python","slug":"开源库/python","permalink":"http://yoursite.com/categories/开源库/python/"}]},{"title":"python-writing","date":"2017-10-07T14:57:49.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/python/python-writing/","text":"ini、properties、yml、“配置文件”语法格式ini——————pythonproperties/yml——-java iniINI所包含的最基本的“元素”就是parameter；每一个parameter都有一个name和一个value，name和value是由等号“=”隔开。name在等号的左边。 所有的parameters都是以sections为单位结合在一起的。所有的section名称都是独占一行，并且sections名字都被方括号包围着（[ and ])。在section声明后的所有parameters都是属于该section。对于一个section没有明显的结束标志符，一个section的开始就是上一个section的结束，或者是end of the file。Sections一般情况下不能被nested，当然特殊情况下也可以实现sections的嵌套。 在INI文件中注释语句是以分号“；”开始的。所有的所有的注释语句不管多长都是独占一行直到结束的。在分号和行结束符之间的所有内容都是被忽略的。 123456789; last modified 1 April 2001 by John Doe [owner] name=John Doe organization=Acme Products[database] server=192.0.2.42; use IP address in case network name resolution is not working port=143 file = \"acme payroll.dat\" ini文件12345678910111213141516171819202122232425262728293031323334353637import configparserconfig = configparser.ConfigParser()config.read('FILE.INI')print(config['DEFAULT']['path']) # -&gt; \"/path/name/\"config['DEFAULT']['path'] = '/var/shared/' # updateconfig['DEFAULT']['default_message'] = 'Hey! help me!!' # createwith open('FILE.INI', 'w') as configfile: # save config.write(configfile)try: from configparser import ConfigParserexcept ImportError: from ConfigParser import ConfigParser # ver. &lt; 3.0# instantiateconfig = ConfigParser()# parse existing fileconfig.read('test.ini')# read values from a sectionstring_val = config.get('section_a', 'string_val')bool_val = config.getboolean('section_a', 'bool_val')int_val = config.getint('section_a', 'int_val')float_val = config.getfloat('section_a', 'pi_val')# update existing valueconfig.set('section_a', 'string_val', 'world')# add a new section and some valuesconfig.add_section('section_b')config.set('section_b', 'meal_val', 'spam')config.set('section_b', 'not_found_val', 404)# save to a filewith open('test_update.ini', 'w') as python parserConfigParser(读取ini文件)的一些问题： 不能区分大小写。 重新写入的ini文件不能保留原有 INI文件的注释。 重新写入的ini文件不能保持原有的顺序。 不支持嵌套。 不支持格式校验。 12345678910111213import sysimport configparserimport eventparsing.test_config as tcdef main(argv): # 读取配置文件： config = configparser.ConfigParser() config.read(argv) heh = tc.testFile(config) heh.hehe()if __name__ == \"__main__\": main(\"/home/ubuntu/workspace/BioEvent/eventparsing/neuralConfig.ini\") #main(sys.argv[1:]) JSON和string/dict转换eval和literal_eval 12import astast.literal_eval(node_or_string) help(ast.literal_eval): Safely evaluate an expression node or a string containing a Python expression. The string or node provided may only consist of the following Python literal structures: strings, numbers, tuples, lists, dicts, booleans, and None. 1234import jsons = \"&#123;'muffin' : 'lolz', 'foo' : 'kitty'&#125;\"json_acceptable_string = s.replace(\"'\", \"\\\"\")d = json.loads(json_acceptable_string)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"language-habit","slug":"language-habit","permalink":"http://yoursite.com/tags/language-habit/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"python","slug":"编程语言/python","permalink":"http://yoursite.com/categories/编程语言/python/"}]},{"title":"docker","date":"2017-10-06T06:54:28.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/docker/","text":"安装方式一https传输与CA证书 12345$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 国内源 12345$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -$ sudo add-apt-repository \\ \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 官方源 123456$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -$ sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 正式安装 sudo apt-get install docker-ce 方式二直接用官方脚本 12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun 安装完后的运行设为开机自启，运行服务 1234$ sudo systemctl enable docker$ sudo systemctl start docker$ sudo service docker start 用户安装完后默认会创建用户组docker，需要把你想要的用户添加进该组，否则“权限不够”，默认只有dockerGroup的人和root有权限。 sudo usermod -aG docker $USER其中$USER修改为你自己的名字即可。 也可以用sudo usermod -aG docker $(whoami) 然后再重新启动电脑，才能免去每次都要sudo docker的烦恼。不然一直报错。 “Got permission denied while trying to connect to the Docker daemon socket” 镜像加速编辑文件/etc/systemd/system/multi-user.target.wants/docker.service 找到ExecStart=改为ExecStart=/usr/bin/dockerd --registry-mirror=https://8myepw5e.mirror.aliyuncs.com https://8myepw5e.mirror.aliyuncs.com需要自己去申请加速器的链接阿里。 私有repository通过docker，官方registry安装 docker run -d -p 5000:5000 registry 装在本地12345sudo docker run -d \\ -p 5000:5000 \\ -v /home/user/registry-conf:/registry-conf \\ -e DOCKER_REGISTRY_CONFIG=/registry-conf/config.yml registry 装在云端123456789$ sudo docker run \\ -e SETTINGS_FLAVOR=s3 \\ -e AWS_BUCKET=acme-docker \\ -e STORAGE_PATH=/registry \\ -e AWS_KEY=AKIAHSHB43HS3J92MXZ \\ -e AWS_SECRET=xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T \\ -e SEARCH_BACKEND=sqlalchemy \\ -p 5000:5000 \\ registry 通过apt，软件安装 12$ sudo apt-get install -y build-essential python-dev libevent-dev python-pip liblzma-dev$ sudo pip install docker-registry docker-compose安装docker-compose异常： Failed to connect to github-production-release-XX-.s3.amazonaws.com port 443:连接超时问题解决 安装方法一：sudo pip install -U docker-compose ​ 我在阿里云上失败了，估计和系统的py包犯冲，py包的确经常会出现这个情况。—不推荐。 安装方法二：curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh &gt; /usr/local/bin/docker-compose &amp;&amp; chmod +x /usr/local/bin/docker-compose ​ 本质上就是下载docker镜像，并用docker运行。———–推荐 安装方法三：自己编译并运行。 1sudo curl -L https://github.com/docker/compose/releases/download/1.8.0/docker-compose-`uname -s``-uname-m` &gt; /usr/local/bin/docker-compose &amp;&amp; sudo chmod a+x /usr/local/bin/docker-compose docker-compose的使用和docker类似 服务(推荐！！)———-类比于“image”————–必须得先up，有了container，他才能start！！！ 建立或重建：docker-compose build 开始：docker-compose start 重启：docker-compose restart 暂停和恢复：pause，unpause 停止：docker-compose stop 容器 建立并运行：docker-compose up，加-d不会在宿主显示。 停止并移除：down 杀死：kill 显示：docker-compose ps 显示内部：logs 基本操作镜像Image 下载 docker pull ubuntu:14.04 查看 docker images 创建方式一 docker diff &lt;容器名&gt;查看改动 docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] 创建方式二 DOCKERFILE docker build [选项] &lt;上下文路径/URL/-&gt; 删除本地 docker rmi [选项] &lt;镜像一&gt;[&lt;镜像二&gt;...] 可以是镜像短ID 、镜像长ID 、镜像名或者镜像摘要 上传镜像 我本来以为上传的只是dockerfile呢，没想到是整个image这个大包，感觉有点太大了吧。好处就是pull下来就不需要再执行我build时，那个漫长过程。 方法如下： 12docker tag XXX YOUR_DOCKERHUB_NAME/YYYdocker push YOUR_DOCKERHUB_NAME/YYY 需要重命名成“YOUR_DOCKERHUB_NAME/YYY”才能允许上传的。 容器Container 创建并运行 docker run -it --rm ubuntu:14.04 bash docker run ubuntu:14.04 /bin/echo &#39;Hello World&#39; docker run --name webserver -d -p 80:80 nginx ​ | 指令 | 用途 || :——- | :————————————— || -t | 命令行,伪终端 || -i | 保持打开 || -P | 随机分配端口，49000～49900,具体是哪个，通过docker ps看。 || -p | 指定分配，具体格式取决于ip:hostPort:containerPort| ip::containerPort | || --name | || -v | || -d | 保证不在宿主显示内容 | ​ 查看docker ps -a查看所有容器，”运行态UP“、”终止态Exit“ 用docker logs ID查看的执行情况。 内部查看 参考使用docker exec -it &lt;CONTAINER_ID&gt; bash 终止docker stop 运行docker start将“终止态”容器重新启动。docker restart将“运行态”容器终止，再重新启动。 删除docker rm只能删除“终止态” 上述的可以用“名字”，可以用“id”，都不需要全拼，和git reset很像，有个大概的，他就能检索到。 仓库Repository官方公共 搜索docker search &lt;镜像&gt; 下载docker pull ubuntu:14.04 命令技巧得到悬空的镜像 docker images -f dangling=true 得到停止的容器 docker ps -f status=exited 得到他们的id。 docker ps/images -q DOCKERFILE尝试ubuntu的apt源如果你要修改源，他应该是和版本对应的。不能瞎来！！！ lucid(10.04) precise(12.04) trusty(14.04) utopic(14.10) vivid(15.04) wily(15.10) 然后国内的ali、163、sohu都有，比如说 12345678910deb http://mirrors.163.com/ubuntu/ wily main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ wily-backports main restricted universe multiverse 也可以采用非覆盖的方式，但是那样会去检查官方源，特别慢。 COPY sources.list /etc/apt/sources.list.d/aliyun.list 一般就直接覆盖了 COPY sources.list /etc/apt/sources.list 问题一我一开始全都是用的docker build .生成的镜像，弄出了一堆没用的。 所以要清除&lt;none&gt;的image和container。 container一般都有名字，是docker给起的。 image倒是没有名字。 一定要先清除container docker rm $(docker ps -a -q) 再清理image docker rmi $(docker images -q -f dangling=true) 尝试一：muduo目前使用如下方式： 1234567891011121314151617181920212223FROM ubuntu:14.04MAINTAINER tommars00@gmail.comRUN mkdir /muduo-dockerWORKDIR /muduo-dockerCOPY sources.list /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y \\ git \\ g++ \\ cmake \\ libboost-dev libboost-test-dev \\ libcurl4-openssl-dev \\ libc-ares-dev \\ protobuf-compiler libprotobuf-devRUN git clone https://github.com/chenshuo/muduo.git &amp;&amp; \\ cd muduo &amp;&amp; \\ ./build.sh -j2 &amp;&amp; \\ ./build.sh install 改进内容： 似乎那个WORKDIR，没啥用，我没必要创建一个新的文件夹。 下面安装muduo库时，感觉可以把cd换为WORKDIR 目前还是没想好该如何去实现“开发、测试”异地用docker的样子，想想不到。而且这个DOCKERFILE，似乎有点臃肿，尤其是C++的编译需要的时间真的很久。 我目前想到的就是，我还需要学习CMAKE，然后我的“开发”就可以实现想muduo库一样，一条命令完成安装。也同样是git clone，这样测试者就能直接看到我的源码。 但我想不通的是双方怎么沟通呢？你提交的修改方案“开发者”怎么看到。 官方对于development的建议 https://docs.docker.com/develop/dev-best-practices/#where-and-how-to-persist-application-data https://docs.docker.com/develop/ 对于怎么加载git/自己的代码，大家争论很多： https://github.com/moby/moby/issues/14704 http://blog.cloud66.com/how-to-get-code-into-a-docker-container/ https://forums.docker.com/t/best-practices-for-getting-code-into-a-container-git-clone-vs-copy-vs-data-container/4077 加载private repository： https://codeday.me/bug/20170514/16081.html 尝试二：hexo我看到的几个版本，绝大多数都是基于node之上的docker组建的，也有很疯狂的，基于nginx，更有甚者基于ubuntu。 坑一 node:alpinne默认安装node8，但是node8不支持hexo-cli。（他报的错是permission denied，我还以为是权限问题，这不是坑人吗？然后又说不是npm的问题，服啦） 必须用mhart/alpine-node:6 用alpine是因为他是个及其精简版的linux，能在上面安装git。 坑二 默认mhart:alpine-node:6只支持sh的，没有/bin/bash。 坑三 所谓的npm install hexo-cli -g的全局安装感觉就是胡扯，我想在docker外面直接利用docker run -d -p 4080:4000 -v XXX imageName hexo s来运行，结果发现容器内，压根没有node_modules，始终运行失败。必须得手动根据package.json来安装。 坑四 默认的hexo s是4000端口，所以你的docker run -p xx:4000后面必须是4000！否则容器外面也还是什么都看不到。 我选择这个思路： 只基于一个简单的linux：alpine，利用node6，配上之前我找到的hexo-theme，完成环境搭建。 我只需要用到预览功能，也就是hexo server。主要是搭配1个数据卷。 12345678# 容器里的 **Hexo** 运行在 **80** 端口上,docker run -d -p 4010:4000 --name hexo-server \\# 数据卷关联 Hexo 里blog的文件夹source,-v &#123;你的博客文件夹路径&#125;/source:/Hexo/source \\# 运行hexo-docker hexo s 我想到的一个应用就是，我在里面运行hexo n来利用模板，虽然模板没几行。。 ​ 我的dockerfile内容为 123456789101112131415FROM mhart/alpine-node:6MAINTAINER tommars00@gmail.comRUN echo \"http://mirrors.aliyun.com/alpine/v3.4/main/\" &gt; /etc/apk/repositoriesRUN apk --update --no-progress add gitWORKDIR /HexoRUN npm config set registry https://registry.npm.taobao.org &amp;&amp; \\ npm install hexo-cli -gRUN git clone https://github.com/tommars00/dockerfile-my.git &amp;&amp; \\ cp -rf dockerfile-my/hexo-docker/hexo-tommars00-theme/* . &amp;&amp; \\ rm -rf dockerfile-my &amp;&amp; \\ npm install . 特殊点： 要改alpine、npm的软件源，否则速度太慢了。 目前暂时没想到怎么解决npm -g无法全局的情况。 我看他们都是搭配sh文件，来提供更厉害的功能。 弄完了之后发现没啥用，因为docker-hexo，他们用的都是自动部署功能，我只用个预览。。。。就当是练手了。 几个被枪毙的想法: git不支持你只copy某个文件夹 关于dockerfile的CMD []有用，但我没用上。 尝试三：brpc 坑一 小巧型alpine没有protobuf等包，所以不行，必须是ubuntu了。 坑二 ubuntu默认不安装realpath，他的sh脚本需要该命令来找到，我看他的报错是realpath not found我以为是我地址写的不对，或者docker比较特别，原来都不是！！就是“command not found” 完全和muduo一样。没啥太多可说的。 尝试四：网站我之前是用Fabric+“nginx—uwsgi—flask”来做的。 我只用到了nginx的静态资源的“反向代理”功能。负载均衡没有用到。 需要配置niginx.conf，uwsig.conf，uwsig.ini。 fabric执行过程 把我的全部代码打包、上传。安装pip内容。 将uwsgi.conf内容复制到/etc/init/uwsgi.conf中，并重启uwsgi。 将nginx.conf内容链接到/etc/nginx/conf.d/中去，并重启nginx。 暂时没有独立的数据库，用的是flask-migrate来管理的 现在：需要用到docker-compose 借鉴： ​ 方案一 ​ 方案二 方案一 容器1：运行nginx 和”容器2“沟通。 容器2：运行flask 直接运行，不再用uwsgi。(方案二用uwsgi) 实现的开发、测试、发布流程如下： 开发 在git上clone我的sheenAPP。 在pycharm上进行开发 测试 利用falsk-script完成初步测试 发布 从git上得到requirement，搭建flask—-webapp容器， nginx—–proxy容器基本定型 docker-compose通过git的代码来让webapp容器运行，并建立两个容器关系。 配置如下： 123456789FROM python:3.4MAINTAINER tommars00@gmail.comRUN mkdir -p /usr/src/appCOPY ./requirement.txt /usr/src/app/ COPY ./pip.conf /root/.pip/WORKDIR /usr/src/appRUN pip install --no-cache-dir -r requirement.txt 12345678FROM nginx:latestMAINTAINER tommars00@gmail.comRUN rm /etc/nginx/nginx.confCOPY nginx.conf /etc/nginx/RUN rm /etc/nginx/conf.d/default.confCOPY sheen_nginx.conf /etc/nginx/conf.d/ 12345678910111213server &#123; listen 80; server_name localhost; charset utf-8; location /static &#123; alias /usr/src/app/static; &#125; location / &#123; proxy_pass http://webapp:8000; &#125;&#125; 12345678910111213141516171819202122version: '2.0'services: webapp: restart: always build: ./web expose: - \"8000\" volumes: - ./Sheen:/usr/src/app command: /usr/local/bin/python /usr/src/app/manage.py runserver --host=\"0.0.0.0\" --port=8000 proxy: build: ./nginx restart: always ports: - \"8080:80\" volumes: - ./Sheen/app/log:/var/log/nginx volumes_from: - webapp links: - webapp 陷阱一： 我的yml的volume宿主地址写的不规范没有用./xxx而是/xxx，导致我的CMD没法执行。 yml的volume加载的确是晚于build的，在build的dockerfile中有添加了一变，修改后无此问题。 同样的问题也出现在了pip更新软件源上，我以为我的docker的pip是在/.pip/但是他们实在root/.pip/我觉得这可以借鉴给其他的。 我也没用他们用的什么gunicorn来运行flask，估计是和python一样的东西。 陷阱二： 还是不太能理解nginx他的conf加载规则。 ​ 目前看到的是两种方案 方案一 123FROM tutum/nginxRUN rm /etc/nginx/sites-enabled/defaultADD sites-enabled/ /etc/nginx/sites-enabled 方案二 12345FROM nginx:latestRUN rm /etc/nginx/nginx.confCOPY nginx.conf /etc/nginx/RUN rm /etc/nginx/conf.d/default.confCOPY sheen_nginx.conf /etc/nginx/conf.d/ 方案一我估计他的nginx.conf写的是用sites-enbale。 方案二是绝大多数nginx默认的情况。对于两个文件我们仅是注释掉了一些内容，而nginx.conf中的http会导向conf.d/*.conf内容。我之前以为只要有一个conf就够了，直接删除外面的导致无法运行。(我是看这个知道的nginx两个conf) 我始终无法运行，一直报错“docker nginx [emerg] host not found in upstream”，也就是代理proxy问题： 怀疑是webapp名字问题（因为docker-compose up启动的时候名字会在后面加_1。） 怀疑是depends_on的关系(因为我无法确定两个container的先后关系)， 怀疑是nginx_conf的proxy_set没有添加，或者多了server_name等内容上的conf问题， 我也怀疑过格式，比如稍加了空白行，稍加了什么空格或者制表符之类的，但是我用nginx -t检查，他认为我的conf并没有问题 怀疑是端口问题，比如yml中是否要加引号之类的—————–最后发现是我的端口号有两个不一致！！！ 陷阱三： 关于volumes_from和nginx-container与flask-container建立的联系。我理解错了。 由于我在“xxx-nginx.conf”有设定static location，它重定向到了/usr/src/app/static该地址是flask-container的地址，由于我们有在nginx-proxy有设定volumes_from，所以能找得到他。但他和我们在proxy设定的volume没有任何关系！！！你不要以为这里的volume会和volumes_from有任何关联，他里没有任何联系。volume是真的在自己的container中挂载了某个数据卷且能在container中找到他，而volumes_from直接借用别人container挂载的数据卷，不能在自己的container中找到他吧？？ 我发现了一点docker的debug方式： ​ dokcer-compose他也是运行几个container，所以可以用docker logs来看里面的运行情况。有的根本就是运行失败。","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"compiler","date":"2017-10-05T14:13:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/cpp/compiler/","text":"预处理器判断C++版本123#ifdef __GXX_EXPERIMENTAL _CXX0X__...#endif 测试12345/* a value to be tested the expected result */// means I expect \"x\" is TRUE#define likely(x) __builtin_expect(!!(x), 1)// means I expect \"x\" is FALSE#define likely(x) __builtin_expect(!!(x), 0) HeaderGuard定义header文件时,一定要注意用”HeaderGuard”!!!!!!!!!!!!!比如： 1234#ifndef ABC#define ABC...#endif 或者 12#pragma once... 这样做的好处是,避免这个头文件重复被定义,因为我们很容易嵌套引用同一个头文件!!! header文件搜索目录顺序(1)当前目录(2)-I指定的目录(3)gcc的环境变量CPLUS_INCLUDE_PATH（C程序使用的是C_INCLUDE_PATH）.Windows的vs可能是INCLUDE(4)gcc的内定目录/usr/include和/usr/local/include和/usr/lib/gcc/x86_64-redhat-linux/4.1.1/include header头文件引用时,如果是C++库里面的我们用&lt; &gt;如果是自定义的,我们用&quot; &quot;去引用他们. \\$PATH是运行可执行文件时的搜索目录，与include头文件的搜索目录无关。 内定目录是由g++的配置prefix指定的，在安装g++时，指定了prefix，那么内定搜索目录就是：Prefix/include和Prefix/local/include和Prefix/lib/gcc/--host/--version/include,编译时可以通过-nostdinc++选项屏蔽对内定目录搜索头文件。 C++编译时，各目录存在相同文件时，先找到哪个使用哪个。 #include “headfile.h”, 搜索顺序(1)(2)(3)(4) #include &lt; headfile.h &gt;, 搜索顺序(2)(3)(4), 不包含(1),即不会搜索当前目录！ 库文件搜索目录顺序-lfoo tells the linker to look for a file named libfoo.a or libfoo.so如果要明确制定是哪一种，则用-l:bar.so 静态库(1)-L指定的目录。比如-L/my/dir/path/(2)环境变量LIBRARY_PATH(3)内定目录/lib和/usr/lib和/usr/local/lib, 这是当初compile gcc时写在程序内的（不可配置的？） 动态库(1)-Wl,-rpath指定的目录。比如-Wl,-rpath=/my/dir/path/，当指定多个动态库搜索路径时，路径之间用冒号”：分隔(2)环境变量LD_LIBRARY_PATH,指定多个动态库搜索路径时，路径之间用冒号：分隔(3)配置文件/etc/ld.so.conf中指定的动态库搜索路径(4)内定目录/lib和/usr/lib和/usr/local/lib, 注意动态库搜寻路径并不包括当前文件夹，所以当即使可执行文件和其所需的so文件在同一文件夹，也会出现找不到so的问题 报错未使用报错： workaround some compiler warnings (such as something not use), 方式一：(void)&#39;variable name&#39;;方式二：编译器选项屏蔽-Wunused cpp和h文件重定义error LNK2005: “” () already defined in main.objlnk2005 already defined in main.obj 重复 如果报错“xxx shadow a parameter”说明 “xxx”它的名字和parameter有一个重复了。 优化线索条件语句gcc提供优化线索，用于if语句。使用gcc -fprofile -arcs来收集关于执行流程和分支走向的实际反馈信息。 限定词linux的gcc还有使用restric或者 thread_等限定词，在func定义中。 可以提供特殊的控制，代码更高效。 判定static_assert(assertation) is used to make assertions at compile-time. When it fails, the program simply doesn’t compile。 Assertation have to be a compile-time constant. Only ordinary assert() can be a run-time value. 可以用于检查类型长度等。（如果程序无法容忍32位机和64位机对于type长度的变化） 信息 函数名 1234567// gcc C99__func__// gcc Backward Compatible__FUNCTION____PRETTY__FUNCTION__ 对于第二个版本。C中两个是相同的，但C++有轻微区别。因为C++的the signature of the function as well as its base name. gcc提供工具来填写LOG文件所需的debug信息 12345// source file name__FILE__// line number__LINE__","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"compiler","slug":"compiler","permalink":"http://yoursite.com/tags/compiler/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"cpp","slug":"编程语言/cpp","permalink":"http://yoursite.com/categories/编程语言/cpp/"}]},{"title":"reference-pointer","date":"2017-10-05T13:01:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/cpp/reference/","text":"reference必须要初始化,不然编译器也不会放过你…. reference to array, 要这么写const char (&amp;p)[num] 容器与引用放进去container和reference。 报错： the component type of containers must be Assignable. References are not assignable! 遍历和constreference和const 报错 binding const xxxx to reference of type xxx &amp; discards qualifiers 123456789set&lt;string&gt; *p1=set1;// Wrongfor(string &amp;word : *p1) ....// Wrongfor(string &amp;word : set1) ... 传递函数返回值、参数,右值报错： invalid initialization of non-const reference of type ‘xxx &amp;’ from an rvalue of type ‘xxx’ 比如说123456789101112131415// definevector f1()&#123;&#125;void f2(vector &amp;v1, vector &amp;v2)&#123;&#125;void f3(vector v1, vector v2)&#123;&#125;// wrongf2(f1(), f1());// rightf3(f1(), f1()); 以下代码的报错内容为 ： invalid initialization of non-const reference of type ‘…&amp;’ from an rvalue of type ‘…’ 123node* f1()&#123;&#125;node*&amp; p = f1(); 左值引用L-Ref传递常发生于pass to function parament或者assignment中，绝对不可能出现在Return中！！！！non-reference—-reference之间相互转化，传递，有何玄机？？ 嵌套函数关于reference的传参问题。下面代码的第二句是错误的。 1234567// Rightvoid f1( T &amp;t)&#123; f2(t); &#125;// Wrongvoid f2(const T &amp;t)&#123; f1(t); &#125; 指针指针和const1234567string s;const char* p= s.c_str();// wrongp[0]=&apos;a&apos;; 指针和引用关于node *p 和 node *&amp;p,即reference和pointer的融合。 当改变ptr本身值是，用 node *&amp;p 当改变ptr指向的值是，用 node *p 千万要小心在function return value中的使用，如果只想着用C++提供的reference功能，就很蠢。 右值引用悬空引用R-reference also is reference。下列代码出现了dangling reference。因为v1无论如何一定会执行dtor的！ 12345xx&amp;&amp; f()&#123; xx v1; return std::move(v1);&#125; 指针和引用较常见的是出现在recursive function中，必须要搞清楚pointer value和pointer reference的区别 pointer and reference当你传递指针给func时，请记住，你的目的是修改指针指向的内容，或者你想要接触到该内容，绝对不是想要修改指针值，因为传递过去的不过是一个copy而已。When we use “pass by pointer” to pass a pointer to a function, only a copy of the pointer is passed to the function. We can say “pass by pointer” is passing a pointer by value.In most cases, this doesn’t present a problem, but problem comes when you modify the pointer inside the function, instead of modifying the value, you are only modifying a copy of the pointer and the original pointer remains unmodified.这一问题最容易发生在“二叉树”这类需要大量指针修改的地方！！！！代码示例：void func(int** ppInt);void func(int*&amp; rpInt);int nvar=2;int* pvar=&amp;nvar;func(pvar);代码分析： 首先func绝对不能修改ppInt的值，因为信任你func，给你这个权限接触到“指针的地址”。ppInt is the ptr-to-ptr. We will never modify this because if we do, We’ll lose our grip on the address of the pointer it is pointing to.所以我的建议是const int** ppInt这只是我个人想法，我想要const的是ppInt，而不是*ppInt,也不是**ppInt！！！ *ppInt is the pointed pointer. If we modify this we are modifying the contents of the pointed pointer, which is an address and in the above example ,pvar. **ppInt is the dereferenced twice variable which is what pvar points to. rpInt is the reference for the pointer,pvar in the above example. *rpInt dereferences what pvar point to, so you get the vcariable the pointer, pvar is pointing to. Do not mistake pointer to pointer arguments. Don’t mistake every ptr-to-ptr arguments purely ptr-to-ptr.An example would be when some write int main(int argc, char *argv[]as int main(int argc, char** argv) where **argv is actually an array of pointers.Or it may be a 2-dimensional array… You can’t use RTTI to find out the type of ref-to-ptr. As typeid() doesn’t support reference types. void指针void指针一般被称为通用指针或泛指针，它是C关于“纯粹地址(raw address)”的一种约定。void指针指向某个对象，但该对象不属于任何类型。请看下例：int* ip;void* p;在上例中，ip指向一个整型值，而p指向的对象不属于任何类型。 void指针使用情形 在C中，任何时候你都可以用其它类型的指针来代替void指针(在C+ +中同样可以)， 或者用void指针来代替其它类型的指针(在C++中需要进行强制转换)，并且不需要进行强制转换。例如，你可以把char *类型的指针传递给需要void指针的函数。 当进行纯粹的内存操作时，或者传递一个指向未定类型的指针时，可以使用void指针。void指针也常常用作函数指针。有些C代码只进行纯粹的内存操作。在较早版本的C中，这一点是通过字符指针char *实现的，但是这容易产生混淆，因为不容易判断一个字符指针究竟是指向一个字符串，还是指向一个字符数组，或者仅仅是指向内存中的某个地址。例如，strcpy()函数将一个字符串拷贝到另一个字符串中，strncpy()函数将一个字符串中的部分内容拷贝到另一个字符串中：char* strepy(char&#39;strl，const char *str2)；char* strncpy(char *strl，const char *str2，size_t n)；memcpy()函数将内存中的数据从一个位置拷贝到另一个位置：void* memcpy(void *addrl，void *addr2，size_t n)；memcpy()函数使用了void指针，以说明该函数只进行纯粹的内存拷贝，包括NULL字符(零字节)在内的任何内容都将被拷贝。请看下例：#include &quot;thingie.h&quot; /* defines struct thingie */struct thingie *p_src，*p_dest；/* ... */memcpy(p_dest，p_src，sizeof(struct thingie) * numThingies)；在上例中，memcpy()函数要拷贝的是存放在structthingie结构体中的某种对象p_dest和p_src都是指向structthingie结构体的指针，memcpy()函数将把从p_src指向的位置开始的sizeof(stuctthingie) *numThingies个字节的内容拷贝到从p_dest指向的位置开始的一块内存区域中。对memcpy()函数来说，p_dest和p_src都仅仅是指向内存中的某个地址的指针。 New–R-reference C++11的std::move应用在muduo的线程库Thread.ccThread::Thread(const ThreadFunc&amp; func,const string&amp; n):func_(func){}#ifdef __GXX_EXPERIMENTAL_CXX0X__Thread::Thread(const ThreadFunc&amp;&amp; func,const string&amp; n)func_(std::move(func)){}#endif Left和Right Reference使用时机是什么？L-Ref&amp;需要和pointer或者copy或者pass by value这些概念相联系。R-Ref&amp;&amp;需要和move这些概念相联系。那使用时机呢？？","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"reference","slug":"reference","permalink":"http://yoursite.com/tags/reference/"},{"name":"pointer","slug":"pointer","permalink":"http://yoursite.com/tags/pointer/"},{"name":"r-reference","slug":"r-reference","permalink":"http://yoursite.com/tags/r-reference/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"cpp","slug":"编程语言/cpp","permalink":"http://yoursite.com/categories/编程语言/cpp/"}]},{"title":"数据库环境","date":"2017-10-05T07:27:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/database/","text":"安装PostGreSQL12sudo apt-get updatesudo apt-get install postgresql postgresql-contrib 创建用户名为“postgres”的linux账号，启动PostGreSql的prompt12sudo -i -u postgrespsql 以后想直接进入该linux账号就使用sudo su postgres 也可以直接在你自己的账号下启动sudo -u postgres psql 可以在“postgres”这个linux账号下，再创建一个新的postgres账号，默认就也创建了同名的database。createuser --interactive创建db，并把当前账号下的db替换掉【都是在postgres这个账号下操作的】12createdb testpsql -d test","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"python-文件处理","date":"2017-10-05T06:41:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/python/library/file-operator/","text":"file1234567file = open('...','w')file.write('...')file = open('', 'r')file.read()file.close() 文件字节流 12&gt;&gt;&gt;import io&gt;&gt;&gt;f = io.open(\"test\", mode=\"r\", encoding=\"utf-8\")","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"file","slug":"file","permalink":"http://yoursite.com/tags/file/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"python","slug":"编程语言/python","permalink":"http://yoursite.com/categories/编程语言/python/"},{"name":"library","slug":"编程语言/python/library","permalink":"http://yoursite.com/categories/编程语言/python/library/"}]},{"title":"python environment","date":"2017-10-05T06:41:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/编程语言/python/python环境/","text":"ubuntupython27_on_debian.sh 先运行 12sudo apt-get updatesudo apt-get upgrade 确保所有的软件无误。【总之前戏要做足】 然后安装 123sudo apt-get install python-pip python-dev build-essentialsudo pip install --upgrade pipsudo pip install --upgrade virtualenv 关于python2和ptyhon3的问题，我的ubuntu一般都是两个默认安装，所以需要安装各自版本的。 123456sudo apt install python3-pippip3 install virtualenvvirtualenv --python=/usr/bin/python3 XXXX# can not workpython3 -m venv XXXX 接着就是针对不同的需求创建虚拟环境。 卸载pip uninstall XXXX windows别用中文的useername来登陆Windows，大坑。因为windows的编码很复杂，我根本搞不清啥原因。 windows有大量的charset，比如windows1255、936等等，这些后面的did无所谓。 一开始安装： 出现了Unicode有问题，我怀疑是中文用户名，然后修改了。 出现缺少C++的build工具（python的包依赖c++编译器），然后按照这个网站vs build—python完成了安装， 又出现了Unicode问题，然后参照有效的解决方案完美解决安装”pycrypto“这个包导致的问题。这个stackoverflow方案说的，我找不到怎么改文档编码，所以没成功，但也可以借鉴。 具体步骤为（1）修改python362\\lib\\site-packages\\pip\\compat_init_.pydi175行为 12345678def console_to_str(s): try: return s.decode(sys.__stdout__.encoding) except UnicodeDecodeError: try: return s.decode('utf-8') except UnicodeDecodeError: return s.decode('cp936') （2）将D:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdint.h文件拷贝到C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.15063.0\\ucrt\\目录下。（3）修改C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.15063.0\\ucrt\\inttypes.h中的第13行（注意当前的编码还有是否为英文输入） 1234// 从#include &lt;stdint.h&gt;// 到#include \"stdint.h\" 上述的文件名灵活修改，我用的是build而不是community版本，但效果一样，具体的版本编号也要做相应修改。 版本兼容pip2、pip3、 py2、py3、 pyqt4、pyqt5 我目前已知的就这些，而且还搭配上ubuntu自带的python，我安装的python，我觉得python是最需要dokcer的，他的版本实在太多了，而且名字都一样，根本不知道package安装在哪里。 pip源windows:%HOMEPATH%\\pip\\pip.iniwindows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下: 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 再比如ali源 123[global]trusted-host = mirrors.aliyun.comindex-url = https://mirrors.aliyun.com/pypi/simple 例子 requirements文件格式123meld==3.14.2pip-autoremove==0.9.0virtualenv==15.0.1 输入输出 12pip install -r requirements.txt --upgradepip freeze &gt; requirements.txt 查看版本 pip freeze | grep ****后面就是你想知道的lib的名称，参考 查看某lib所有可允许的版本 安装，卸载1234pip install scapypip install scapy==2.4.2pip uninstall scapy","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"},{"name":"python","slug":"编程语言/python","permalink":"http://yoursite.com/categories/编程语言/python/"}]},{"title":"爬虫","date":"2017-10-05T06:41:54.000Z","updated":"2019-08-06T15:20:43.933Z","path":"wiki/开源库/python/crawl/","text":"总结（1）找一下网页的规律，然后BeautifulSoup解析一下网页，再使用request做HTTP请求， （2）cookies,sessions, login3.反爬：需要登录才能获得想要的数据要弄通这一个的反反爬我觉得有必要弄明白登录的一些知识，如cookies、session、token现在常见的就是session和token，因为将用户敏感信息存到cookies中非常不安全session其实非常简单，就是用户信息存到服务器中，将对应这个用户信息的唯一id发放给用户，一般存到cookies，理解了这种登录模式，使用反反爬就明确了，将自己正确登录后的cookies保存下来，放到爬虫的cookies中，每次请求都带上，那么服务器就会认为你是登录的用户token其实也不难理解，很多网站在用户登录成功后，会使用唯一的token来标识不同的用户，那么每次请求头中包含这个token就OK了，这里要注意一下token的格式 还有登录模拟，用start_request （3）遇到动态页面，找 post 的 url， 或者上 Selenium4.反爬：JavaScript逻辑复杂化界面很多时候界面的数据不是静态的，而是动态的，如通过ajax获得的数据，如果没有使用JavaScript来操作这些数据，那么我们自己访问这个ajax接口就可以获得数据了，那么有些网站，返回的数据非常奇怪，只有通过网站的JavaScript处理后，才是人看的数据，这就非常尴尬了，那么一般有两种方式 反反爬：a. Python模仿JavaScript中的逻辑，因为都可以获得原始的数据，只是人家的数据通过JavaScript处理后才是正常的，那么我们可以使用python实现JavaScript中的逻辑，就可以获得数据了，当然这对JavaScript功底有一定的要求 b. PhantomJS+Selenium，这个其实就没什么好说的了，就会利用自动测试，使用浏览器来获得数据，获得的这些数据都是经过对方JavaScript处理过的可用数据，就是有点慢，不适合分布式爬虫，当然有人说PhantomJS是可以被识别出来的（携程的某次分享） （4）CAPTCHA———-verify code———-image anlyse2.反爬：弹出验证码反反爬：a. 手动输入验证码，就是将验证码图片下载到本地，然后通过PIL库显示一下，当爬虫遇到验证码时会显示出来，我们手动填一下b.使用打码平台，将验证码对接到相应的打码平台，平台会帮我们输入正确的验证码，平台怎么输入正确验证码的呢？它其实就是租人来填，填多少个有相应的金额可以获取c.使用Python的图像识别库，如PIL，对验证码图片进行处理，让词表库匹配一下，最后自动填写。我有一个想法就是通过CNN卷积神经网络对验证码中的图片，将验证码图片分割成一个个的字符，获得足够多的字符就可以喂养给CNN，当做训练数据，CNN对图像识别的准确率还是很高的，有兴趣的人可以看看CNN识别手写字体MNIST数据集，目前我还没有这样弄过。当然还有一些很变态的验证码，比如Google的验证码，要你找出图片中的店铺之类的，这个没想法，欢迎大神提点，对于滑动验证码已经有人做了比较成功的尝试 jTessEditor+TesseractOCR 1.反爬：判断是否为浏览器（最初级反爬）反反爬：伪造请求头headers，其实就是为User-Agent赋值 遇到反爬，学middleware， 学构建random proxy， random header。 遇到链接失败，考虑如何重复爬取失败页面，考虑用retry middleware 遇到爬取链接数量上规模后，要考虑上分布式用上scrapy-redis，同时待爬取队列管理也更方便。 用了多线程多进程 爬取后后台数据存取考虑使用Mongodb，就要考虑编写pipeline 处理 items，存档到数据库中。 遇到图片，文件想下载，就要学习一下image/file pipeline 常用库requests官方 对于Authentication的处理requests.get(url, auth=(&#39;user&#39;, &#39;pwd&#39;)) 定制headPython send POST with header教程 urllib url-encode application/x-www-form-urlencoded","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"crawl","slug":"crawl","permalink":"http://yoursite.com/tags/crawl/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"python","slug":"开源库/python","permalink":"http://yoursite.com/categories/开源库/python/"}]},{"title":"muduo-python","date":"2017-10-05T06:41:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/开源库/cpp/muduo/","text":"把lib写成python，几个想法 寻找比对，即C++与python的lib的功能比对 我想的是一步步的构建muduo，所以希望git能体现这种递进的关系——用Tags functional programming，C++和python的实现方式区别 C++的全局变量，的指针（地址），用python如何表示，或者其替代品？？ 线程变量+全局变量，这个在python该怎么做啊？？","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/tags/开源库/"},{"name":"muduo","slug":"muduo","permalink":"http://yoursite.com/tags/muduo/"}],"categories":[{"name":"开源库","slug":"开源库","permalink":"http://yoursite.com/categories/开源库/"},{"name":"cpp","slug":"开源库/cpp","permalink":"http://yoursite.com/categories/开源库/cpp/"}]},{"title":"Windows","date":"2017-10-05T06:31:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/Operator System/windows/","text":"win10workspacectrl+win+左右方向键win+tab wordword的软回车软回车是^l，l是小写的L。回车键对应的是^p，p也是小写。替换可以这样写。 报错0xc00007b 1 check binary x86 or x64 windows servewr 2008 view file extension 注册表","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"office","slug":"office","permalink":"http://yoursite.com/tags/office/"},{"name":"word","slug":"word","permalink":"http://yoursite.com/tags/word/"},{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"Operator System","slug":"工具/Operator-System","permalink":"http://yoursite.com/categories/工具/Operator-System/"}]},{"title":"Powershell","date":"2017-10-05T06:31:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/Operator System/powershell/","text":"常用命令shift+right mouse 可以在该文件夹下打开powershell powershell真的很好用，他不比bash差，也能做ping、traceroute这些功能 不要人云亦云的小瞧Windows powershell查找文件 递归查找当前文件夹以sh为扩展名的文件dir ./*.sh -r where.exe vcpkg搜索可执行文件type 1.txt类似linux的echo 1.txt 设定环境变量参考文档 powershell 设置`setx VCINSTALLDIR &quot;D:\\VC&quot;` 显示所有 Get-ChildItem Env: 显示某个 echo $Env:VCINSTALLDIR 环境变量 tommars用户变量———-setx设置的 系统变量 环境变量12dir env:dir env:VAR 1选定内容，鼠标右键一下即完成复制，在输入为止，鼠标右键，即完成粘贴 21234Get-Aliasdir----------Get-ChildItemcd-----------Set-Locationcat----------Get-Content 3如果希望将字符串解释为命令名，则使用调用运算符( &amp; )，如下所示：PS&gt; &amp; &#39;C:Program FilesIISMicrosoft Web Deploymsdeploy.exe&#39;","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"powershell","slug":"powershell","permalink":"http://yoursite.com/tags/powershell/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"Operator System","slug":"工具/Operator-System","permalink":"http://yoursite.com/categories/工具/Operator-System/"}]},{"title":"CMD","date":"2017-10-05T06:31:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/Operator System/cmd/","text":"set设定环境变量 cmd 设置 set CL=/FI &quot;%VCINSTALLDIR\\stdint.h&quot; %CL% 显示所有set 显示某个echo %CL% cmd设置环境变量，等号右边不要带引号，否则也会被赋值进去 process tasklist windows kill process 12345netstat –aon | findstr \"ipPort\"tasklist | findstr \"PID\"taskkill /f /t /im 程序名taskkill /?taskkill /PID *** system info win10 get version systeminfo.com 命令 按键 功能 DOSKEY /h 显示历史命令 tree \\? 文件夹树级结构 ren file1 file2 重命名文件，但是不支持深层路径的指明 move file1 file2 类似linux的mv 删除文件Delete folder(s) rd 查找文件for /r 用法简介 用了Linux下的find命令，觉得查找文件很方便，那么在windows下有没有类似的命令可以遍历目录并通过文件名找到文件呢？答案是有：Windows下的 for /r 命令具有与Linux下 find 命令类似的功能，使用语法上类似： find /r 目录名 %变量名 in (匹配模式1,匹配模式2) do 命令 匹配模式可以是通配类似于： *.jpg：所有.jpg后缀的文件 test：所有名称中包含test的文件 注意: 匹配模式中至少带上1个*号 匹配内容仅限于文件名，不会匹配目录名 如果仅是查找和输出文件名，do后面的命令可以用@echo %变量名，即：for /r 目录名 %i in (匹配模式1,匹配模式2) do @echo %i 常用的例子： 将TestDir目录及所有子目录中所有的文件列举出来for /r TestDir %i in (*) do @echo %i C:\\Users\\cashey\\Desktop\\TestDir\\b.jpg C:\\Users\\cashey\\Desktop\\TestDir\\c.png C:\\Users\\cashey\\Desktop\\TestDir\\doc\\1.txt C:\\Users\\cashey\\Desktop\\TestDir\\doc\\2.txt C:\\Users\\cashey\\Desktop\\TestDir\\src\\test.py 在TestDir目录及所有子目录中找出所有的txt文件for /r TestDir %i in (*.txt) do @echo %i C:\\Users\\cashey\\Desktop\\TestDir\\doc\\1.txt C:\\Users\\cashey\\Desktop\\TestDir\\doc\\2.txt 在TestDir目录及所有子目录中找出所有的txt及jpg文件for /r TestDir %i in (*.txt,*.jpg) do @echo %i C:\\Users\\cashey\\Desktop\\TestDir\\b.jpg C:\\Users\\cashey\\Desktop\\TestDir\\doc\\1.txt C:\\Users\\cashey\\Desktop\\TestDir\\doc\\2.txt 在TestDir目录及所有子目录中找出所有文件名中包含test的文件for /r TestDir %i in (*test*) do @echo %i C:\\Users\\cashey\\Desktop\\TestDir\\src\\test.py 需要注意的点,匹配模式中如果不带*号，并不会精确匹配文件名，而会输出所有子目录拼接上该匹配模式的结果，像下面这样：目录中事实上不包含任何名称为abc的文件for /r TestDir %i in (abc) do @echo %i C:\\Users\\cashey\\Desktop\\TestDir\\abc C:\\Users\\cashey\\Desktop\\TestDir\\doc\\abc C:\\Users\\cashey\\Desktop\\TestDir\\src\\abc 上面这样的输出一般不是你预期的，模式里至少需要带上1个*号 netipconfigipconfig /all显示所有信息，包括MAC address routeroute print route -p ADD 192.168.0.0 MASK 255.255.255.0 192.168.0.1-p表示永久路由，add表示向目标网段的某个地址，Mask为子网掩码，末尾是去往目标网段的下一跳。 tracerttracert www.baidu.com,可以认为是trace route的缩写 netsh netsh使用 cmd view tcp setting Enable/Disable TCP Auto Tuning auto tuning in windows netsh interface tcp show global netsh int tcp set heuristics disabled netsh int tcp set global autotuninglevel=disabled","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"Operator System","slug":"工具/Operator-System","permalink":"http://yoursite.com/categories/工具/Operator-System/"}]},{"title":"markdown语法","date":"2017-10-05T06:31:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/markdown/","text":"referencelearn-md 表格左对齐、右对齐、居中 1234| Title | Description || :- | :-: || Version | 0.0.1 || Editor | [Melo618](mailto:Editor@Email.com) | 列表符号*，-，+这3个相同。1.也可以 123456* 第一行* 第二行* 第三行6. 第四行5. 第五行4. 第六行 引用 &gt;符号表示引用，可简写于第一行，也可以每一行都添加。 区块的引用可以嵌套，只需要在层次数上加上同等数量的&gt;符号。 引用内可以使用其他Markdown语法，包括标题、列表、代码区块等。 语法：12&gt; 引用&gt; &gt; 引用中的引用 效果： 引用 引用中的引用 链接方括号内是显示出的名字，尖括号内是连接的真正地址。 语法：[show](https://google.com/)效果：show 语法：”行内式连接”[腾讯网](http://qq.com &quot;访问腾讯网&quot;)语法：”参考式连接”(第1行第2个方括号内就是”辨识标记“)12[腾讯网][url][url]: http://qq.com &quot;访问腾讯网&quot; 图片语法：”行内式连接”![图片](http://i0.hdslb.com/8d.jpg &quot;兔子&quot;) 语法：”参考式连接”12![图片][he][he]: http://p4.music.126.net/4964.jpg &quot;乐团&quot; 删除线语法：~~删除~~效果：删除 分隔线使用三个以上的*、-来建立一个分隔线，行内不能有其他字符。 ***或者--- 标题一级、二级、三级 12345######","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"语言","slug":"语言","permalink":"http://yoursite.com/tags/语言/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"IDE","date":"2017-10-05T06:14:54.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/工具/IDE/IDE/","text":"综述 eclipse intelij【A】 pycharm【A】 qt visual studio matlab vs与eclipse 功能 eclipse vs2010 搜索文件 ctrl+shift+r 需插件支持[ctrl+K,O]或[alt+shift+o] 格式化代码 ctrl+shift+f ctrl+K,F 搜索含字符串的文件 ctrl+h ？？ 注释（取消） ctrl+/ ctrl+K,C 和 ctrl+K,U 块注释（取消） ctrl+shift+/或\\ ?? 查看当前变量值 ctrl+shift+d ？？ 查看当前函数的全项目调用 ctrl+shift+g ？？ 跳转定义 F3 F12 单步执行step into逐语句 F5 F11 step over逐过程 F6 F10 执行到下个断点 F8 F5 智能提示 Alt+/ ？？ 启动调试 ？？ F5 停止调试 ？？ Shift+F5 eclipse与intellij 功能 intellij eclipse 继承体系 ctrl+H ctrl+T 跳转实现 ctrl+alt+B或者ctrl+B f3 上/下个光标 ctrl+alt+左右箭头 ctrl+左右箭头 查找引用 alt+f7 ctrl+shift+G 打开类 ctrl+N ctrl+shift+R 格式化 ctrl+alt+L ctrl+shift+F 新建 alt+insert，然后直接输入字母即可快速定位，且支持maven的pom ctrl+N,然后在选择class、package等。maven的pom打开他是以特殊的editor打开 重命名 shift+f6 alt+shift+R 清除无效 import ctrl+alt+O ctrl+shift+O 单步执行step into逐语句 f7 f5 step over逐过程 f8 f6 执行到下个断点 F9 F8 代码缩写 代码缩写 intellij eclipse main psvm(public static void main) main system.out sout syso for fori或iter for然后选择 matlab与vsdebug都支持在Editor界面的最左端用鼠标点一下，设置断点 功能 Matlab VS2015 注释和去掉注释 Ctrl+R（加）Ctrl+T（去） （类似Emacs），Ctrl+K, Ctrl+C（加）Ctrl+K, Ctrl+U（去） 运行和Debug F5(开始debug),F10(StepNextLine),F11(StepInto),Shift+F11(StepOver),F12(ToggleBreakpoint) Ctrl+F5(无Debug开始),F5(开始debug),F11(StepInto),F10(StepOver),F9(ToggleBreakpoint) 跳转函数/变量定义 Ctrl+D（GoToDefinition） F12（GoToDefinition） 代码折叠展开 Ctrl+=（全折） Ctrl+shift+=（全折） Ctrl+M, Ctrl+O（全折） Ctrl+M, Ctrl+P（全开）","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"QT","slug":"QT","permalink":"http://yoursite.com/tags/QT/"},{"name":"VS2010,2015","slug":"VS2010-2015","permalink":"http://yoursite.com/tags/VS2010-2015/"},{"name":"pyCharm","slug":"pyCharm","permalink":"http://yoursite.com/tags/pyCharm/"},{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"},{"name":"eclipse 6,oxygen","slug":"eclipse-6-oxygen","permalink":"http://yoursite.com/tags/eclipse-6-oxygen/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"ubuntu","date":"2017-10-03T03:15:58.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/Operator System/ubuntu/","text":"一些用到的cmd,或者视窗快捷键 ubuntu便捷利用他的视图界面。 ubuntu更新ali源 多界面workspace“外观-&gt;行为-&gt;开启工作区” Super+S显示所有的WorkSpace Ctrl+Alt+arrow 切换 调整server分辨率vmware装Ubuntu 调整 试过了，都不行 reboot12shutdown -r nowshutdown -h now super+W是当前Workspace，多窗口的显示 快捷键设置在右上角输入“shortcut”，然后选择Keyboard，在里面找到“shortcut–&gt;Custom Shortcut”，然后就可以为快捷键设定命令。 比方说给Super+F1设定为xinput-enble 12就是启动触摸板。xinput-disable 12功能相反—–id号取决于系统，用命令xinput来查看。 笔记本触摸板，因为开了摄像头，Integrated_Webcam_HD ，xinput的list多了这个内容，导致touchpad号码变了。 开机启动在右上角输入“startup”，然后选择Application Startup，然后就可以设定开机自动执行的命令。可以add，可以remove。 比方说添加命令sslocal -c /home/tommars/Documents/ss-ipv6.jason 用于执行启动本地ss来翻墙，注意，路径必须是绝对路径，不能用～/。 查询软件安装目录The binary for anything that you install using apt-get dpkg is usually either in /bin or /usr/bin directories from where you can run the program. You can also try to use the which command to locate pathnames of files which would be executed. So in your case, on a terminal, type: which visualStudioCode apt问题fedora：yummac：brewubuntu：apt 查询软件的依赖，可以看https://packages.ubuntu.com/系统的版本代号/软件包名称 Bionic 18Xenial 16Trusty 14 linuxMint与ubuntu对应号 镜像：阿里、163、各个大学清华https://mirror.tuna.tsinghua.edu.cn/help/AOSP/ 1unmet dependencies, … “but it is not going to be installed” 解决方案 12345678#This would install any dependencies that your previous installs missedsudo apt-get install -fsudo dpkg --configure -aapt-cache policy libncurses5-dev libncurses5sudo dpkg --force-all -r libncurses5-dev 添加软件源举例地址： http://apt.llvm.org/trusty/dists/llvm-toolchain-trusty-7/main/binary-amd64/ 其中 dists和main很常见，不清楚含义。pool也很常见 xenial是系统版本 binary-amd64是系统的32/64版本（binary-i386) llvm-toolchain-trusty-7是软件名 该网址底下有个Packages，里面是该软件需要用的依赖列表。 ppa是什么 官方帮助文档 帮助文档 launchpad软件源 gcc软件举例 deb lines are relative to binary packages, that you can install with apt. deb-src lines are relative to source packages (as downloaded by apt-get source $package) and next compiled. Source packages are needed only if you want to compile some package yourself, or inspect the source code for a bug. Ordinary users don’t need to include such repositories. 具体操作： Use the add-apt-repository (or symlink apt-add-repository) command to add launchpad PPA to your system. You just need to provide launchpad reference address as the following command.sudo add-apt-repository ppa:libreoffice/ppa For other hosted repositories, can be also configured by providing its reference as below:add-apt-repository &#39;deb http://archive.getdeb.net/ubuntu wily-getdeb games&#39; You can just create a file in /etc/apt/sources.list.d directory. The file name must end with .list extension. The apt package manager also read repository configuration files from here.1234vim /etc/apt/sources.list.d/games.list内容填deb http://archive.getdeb.net/ubuntu wily-getdeb games 2问题apt: relocation error: version GLIBCXX_3.4.21 not defined in file libstdc++.so.6 with link time reference 好像没什么用12345wget http://security.ubuntu.com/ubuntu/pool/main/g/gcc-5/libstdc++6_5.4.0-6ubuntu1~16.04.10_amd64.debsudo dpkg -i libstdc++6_5.4.0-6ubuntu1~16.04.10_amd64.deb# I also found this helpfulsudo apt-get -f install 3问题The following packages have been kept back:” 好像没什么用解决方案 4软件deb的解包、打包 方式一 或者将文件先压缩成tar.gz再sudo alien --to-deb ~/Desktop/filename.tar.gz将该文件变为deb文件","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"Operator System","slug":"工具/Operator-System","permalink":"http://yoursite.com/categories/工具/Operator-System/"}]},{"title":"hexo-install","date":"2017-10-02T20:14:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/hexo-install/","text":"hexo前提软件 git sudo apt-get install git node.js sudo apt-get install nodejssudo apt-get install npm 由于我安装“hexo-theme-Wikitten”始终无法运行。问题通过仔细产看某个插件的提示（hexo-generator-json-content）报错，我的nodejs安装版本过低，我之前是根据某个网站，他告诉我下了个安装包，然后解压安装的，才4.4。真是坑，由此也产生了后续“hexo安装”我总得指明是在/usr/local/node/bin/npm。 更新下安装过程。(无需再安装npm）12curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs npm简单学习http://www.ydcss.com/archives/18这个不懂，导致我的hexo踩了好多好多坑。 一定要注意他安装的版本号！！！软件、自身都有关。 只介绍安装相关， -g 全局安装--save 安装完了之后，还会写入本地的package.json文件，会自动找位置写，不会覆盖。很重要的工具，我的theme用的是第三方的，需要额外的插件，而travis自动部署时，也是看这个package.json他才知道安装哪些额外的！！ hexo安装因为国内防火墙缘故。npm config set registry https://registry.npm.taobao.org 安装sudo npm install -g hexo-cli 在想要创建blog的位置1234mkdir HEXO &amp; cd HEXOhexo init blog_namecd blog_name 一定是在该文件夹下安装hexo否则该文件夹下的node_modules没有该插件。为了防止“permission denied”。sudo /usr/local/node/bin/npm install hexo --save然后安装hexo的插件，仍然是用sudo，插件包的设置默认在package.json中sudo /usr/local/node/bin/npm install -g 使用hexo -v检查下，发现：我的版本还会报错“ERROR Plugin load failed: hexo-renderer-marked”，手动更新下这个插件。sudo /usr/local/node/bin/npm install hexo-renderer-marked@0.2.3 nodejs报路径错误 官方预制版hexo generate也可以用hexo ghexo server也可以用hexo s 然后在local:4000就可以看到博客了。 更新下内容，安装过程为1234mkdir HEXO &amp; cd HEXOhexo init blog_namecd blog_namehexo s 即可。 添加主题“hexo-theme-Wikitten”严格按照作者的文档进行即可。https://github.com/zthxxx/hexo-theme-Wikitten 按照作者的做，会出现git submodule。我后续depoly出问题。所以是简单的复制粘贴。具体内容参照下面的部署经验。 部署方案+内容更新https://hexo.io/zh-cn/docs/deployment.html 官方版本的“_config.yml”让githubPage来部署。用travis自动更新。配置内容： 12345# hexo _config.ymldeploy: type: git repository: git@github.com:&lt;user_name&gt;/&lt;user_name&gt;.github.github.io branch: master 安装插件来支持git部署。sudo /usr/local/node/bin/npm install hexo-deployer-git --save 使用hexo deploy或者hexo d来完成部署。 travis自动更新https://blog.zthxxx.me/posts/Build-Hexo-Blog-by-Travis-CI/ zthxxx先生实现的是这么个东西： ​ 在githhub上有个“wiki-site”的reposity，他有两个分支，一个是主分支，就是正常的hexo所在的文件，我们的md文件在这儿编辑；一个是副分支，他是hexo生成的html等静态文件，并让travis把他们部署在这儿，并且设为当前活动分区。(github.io规定了，只有叫master和gh-pages的可以作为他的显示分区，所以。。他的副分区就叫gh-paegs) 然后里面主要是设定3个文件.travis.yml和travis_env_init.sh 和2个_config.yml（一个是在外文件夹，一个是在theme文件夹） 其中只有外文件夹的_config.yml是”副分支“ 因为他才有”deploy“的字眼，其余都是主分支。 travis的自动更新脚本.travis.yml先生写的很好，用的是setting-&gt;Personal access tokens实现的，既方便又不泄漏个人信息。（这个工具厉害，大家还拿他来在github上发布软件–release） 一开始始终不行，我还怀疑是token出问题，之类的，后来验证都没事，就是下面这几个神坑害的。 本地安装travis是 12345678sudo apt-get install ruby`ruby -e 'puts RUBY_VERSION[/\\d+\\.\\d+/]'`-dev # gem命令需要安装rubygem sources #查看原有的官方源gem source -r https://rubygems.org/ # 删除 rubygems 官方源，经常被“墙”gem source -a http://mirrors.aliyun.com/rubygems/ # 添加aliyun 源gem install travis --no-rdoc --no-ri --verbose # 安装Travisgem install travistravis login --github-token 'token' # token即是上面复制的那个token串travis whoami # 提示用户信息 别用别的命令，尤其是ruby，不过本地其实没必要安装，一点用都没有。 踩的几个坑（目前仍未解决，也暂时不需要）： submodules 我们的主题zhxxx-hexo-theme本身也是个github上的repo，如果用git clone来安装，则会在外面commit时不会理会这个主题。本来也没什么问题，而且我觉得也很合理（便于主题能跟着作者一起更新） 问题出现在用travis进行自动部署的时候，他会报错，”git submodule”失败，我实验了好多次都不行，不知道是不是因为我的分支问题，因为我一开始没搞懂作者在干什么。反正最后放弃了，我直接手动复制粘贴的该theme的文件。 他报的是Permission denied (publickey). fatal: Could not read from remote repository.这种错误。也难怪我会多想。 gulp 这个是作者新开发的玩具，然后我就中弹了，他好象是用来压缩静态文件的，没有用到，也一时会解决不了就算了。 好像要这么些 123456\"gulp\": \"^3.9.1\",\"gulp-htmlclean\": \"^2.7.6\",\"gulp-htmlmin\": \"^3.0.0\",\"gulp-imagemin\": \"^3.1.1\",\"gulp-minify-css\": \"^1.2.4\",\"gulp-uglify\": \"^2.0.0\", ​ travis的yml脚本书写。 其实就是node.js吧，我反正不太懂这个，就是照着填的。云里雾里的。 git的分支问题。目前已大致了解了。git branch XXX是创建分支，git checkout XXX就跳到XXX分支了，在XXX分支使用git merge YYY就把当前的和YYY的合并了，有的还会出现“冲突”提示，并在具体文本中标注。 作者到底有没有和github.io连上线啊，感觉他是在单干。我截止目前为止，还没正式上线，就是跨两个repo的上线。 云端运行hexo server来部署。配置云端的git服务器来更新。以后在想办法。 http://xhay1122.com/2016/02/26/2016-02-26-HexoToOnline/#more 可以用gitlab？？听上去用docker很容易实现。 http://blog.devzeng.com/blog/simple-usage-of-gitlab.html md编辑器123456789# optional, but recommendedsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE# add Typora's repositorysudo add-apt-repository 'deb https://typora.io ./linux/'sudo apt-get update# install typorasudo apt-get install typora 博客写作https://wizardforcel.gitbooks.io/markdown-simple-world/hexo-tutor-7.html 这个是在source/_drafts中： hexo new draft &quot;xxx&quot; 生成的MD不会被hexo generate，除非你在配置文件中render_drafts: true，或者用hexo s --drafts也能显示。等你觉得实际成熟也可以把草稿变文章hexo publish [layout] &lt;filename&gt;。 这个是直接在source/_post中： hexo new &quot;xxx&quot;或者 hexo n &quot;xxx&quot;都可以，会按照默认的layout生成MD文件。也可以指定你想要的layout。 模板都是保存在scaffolds中，必须要有与之同名的文件。默认模板是post。 分类categories和标签tags可以多个，如果你觉得有必要的话。 12345categories:- 日记tags:- Hexo- node.js 可以添加文章摘要，避免一下显示太多内容。 1234567891011121314---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown---我是短小精悍的文章摘要(๑•̀ㅂ•́)و✧&lt;!-- more --&gt;紧接着文章摘要的正文内容 问题一我写作的时候hexo n &#39;xxx&#39;导致hexo g失败。 “hexo generate fail - Template render error: (unknown path) unexpected token: }}” 我一开始搜索问题时，没注意到后面的“unexpected token: }}”导致得到的解决方法如下： “This error indicate a syntax error in one of your post/page file. To find which one, try hexo generate –debug” 然后怀疑是，我忘记对模板自动升的tag做一些内容添加。用debug模式也得不到额外的定向到某个文件的能力。 但后来还是一直失败，加上后面的“unexpected token: }}”再搜索得到结果为别人经验 是由于我的flask.md中，我添加了关于jinja2的一些经验，里面有关于blokc的内容会涉及到的符号{ {不管在哪儿，hexo都会想要给他配对，我不知道为什么。然后只能给他们添加空格了。 还有种解决方式官方issue maybe “{ { } }” in your .md files!modified these files by “{/{ }/}”that’s because. that hexo doesn’t support “{ {}}”you can have a try","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"git-use","date":"2017-10-02T20:14:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/git/","text":"用户名初始化设定git config --global user.email &quot;you@example.com&quot;git config --global user.email &quot;Your name&quot; 查看git config --global --list 也有git config --local --list 为了不总是输入密码用ssh验证。生成密钥。ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;然后都用enter确定即可，也没啥好设置的。 在你的github设定中添加该ssh-key即可。内容在~/.ssh/id_ras.pub windowswindows的git工具为git bash/gui前面那个用的习惯，后面的优点太花哨了，没用过呀。 还需要额外操作没配置ssh-agent使用SSH key。 1234# 在后台启动 ssh-agenteval $(ssh-agent -s)# 将SSH私钥添加到 ssh-agentssh-add /c/Users/chenjs/.ssh/id_rsa 用于travis的验证publish_key 使用远程有，就clonegit clone git@github.com:tommars00/RepositoryName.git 远程没有，就把本地的推送上去git remote add origin `git@github.com:tommars00/RepositoryName.gitgit push -u origin master` 别用http协议，每次都要输入username和password，好麻烦。不小心创建错了就删除git remote rm origin 本地就是，常用的几个命令git init git add -Agit commit -m &quot;xxx&quot; git statusgit log -1 因为之前修改的记录太多了，已经很久远了，我的本地的某个dir是之前的版本，然后我在此基础上修改了下内容，再push，他就提示我Github “Updates were rejected because the remote contains work that you do not have”然后我按照我上的建议就使用。git pull origin master好像发生了合并，但我现在只有2个提交记录了，之前的提交记录被隐藏到了后台了。不是很懂呀，反正没问题，使用该命令前我还保险起见备份了下，发现担心是多余的。 只提交特定文件夹的改动内容git add My_Dir和git commit -m &quot;xxx&quot;即可 删除不小心提交的改动(仅限本地，尚未push的内容！！)git reset --hard HEAD^其中HEAD表示当前版本，即最新的提交，上个版本为HEAD^,上上个版本HEAD^^,再在之前的100个版本，写成HEAD~100 撤销 用git reset HEAD全部撤销。 用git reset HEAD &lt;file&gt;撤销特定 回退 修改已提交 重写历史 修改已提交的commit message How to modify existing, unpushed commits (error: path … is unmerged) ‘git reset –hard HEAD’ git远程回退 远程回退 远程回滚 Git “You have not concluded your merge” and nothing 改动内容，不仅仅只是add还有rmgit rm -r My_Dir如果不添加-r会报错”fatal: not removing ‘My_Dir’ recursively without -r” ssh-key问题1234567891011@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0777 for &apos;/home/tommars00/.ssh/id_rsa&apos; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.bad permissions: ignore key: /home/tommars00/.ssh/id_rsaPermission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists. 使用chmod 400 ~/.ssh/id_rsa可以解决该问题 一些概念 star发展过程我无所谓，但某个时候我会回来，看那个时候的发展程度。 watch表示需要监控这个项目以后的发展，注重整个过程。 fork表示我发现你写屎了的地方，要动你代码了。 好习惯因为经常会多地更新wiki-blog。在ubuntu、win、mobile等。 每次修改git之前，先用git pull origin master和云端同步，然后再动笔开始写东西。 hookhook declined to update refs/heads/external_pub 公司要求配置hook，规范commit内容","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"cloud-server use","date":"2017-10-02T20:14:54.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/network/cloud_server/","text":"阿里云本地ssh登录ssh root@XX.XX.XX.XXIP地址用公网的IP。输入密码即可。","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"network","slug":"工具/network","permalink":"http://yoursite.com/categories/工具/network/"}]},{"title":"sublime","date":"2017-10-02T16:28:21.000Z","updated":"2019-08-06T15:20:43.929Z","path":"wiki/工具/IDE/sublime-use/","text":"install Package Controlshortcut ———-Ctrl+` /Sublime Text 2 代码/1import urllib2,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation') /Sublime Text 3 代码/1import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) using Package Control install pluginshortcut ———-Ctrl+shift+P in windows input “PCI”————then you can install anything [any pulgin only need some characters] install process————benethe the WINDOWS","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IDE","slug":"工具/IDE","permalink":"http://yoursite.com/categories/工具/IDE/"}]},{"title":"Welcome tom's Wiki","date":"2017-01-21T17:55:57.000Z","updated":"2019-08-06T15:20:43.925Z","path":"wiki/index/","text":"一些工程经验 一些工程想法 一些工程问题 都很琐碎，很絮叨，有的可能看上去有点蠢。 好记性不如烂笔头 写作宗旨： 坚决不写任何“论述性、原理性”内容，就写“经验性”内容。 可以不太苛求文件梳理，把tag写好，让网站的搜索引擎来完成快速检索。","tags":[],"categories":[]}]}